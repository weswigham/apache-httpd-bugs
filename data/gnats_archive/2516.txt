Received: (qmail 3304 invoked by uid 2012); 27 Jun 1998 13:43:33 -0000
Message-Id: <19980627134333.3303.qmail@hyperreal.org>
Date: 27 Jun 1998 13:43:33 -0000
From: NAKAJI Hiroyuki <nakaji@zeisei.dpri.kyoto-u.ac.jp>
Reply-To: nakaji@zeisei.dpri.kyoto-u.ac.jp
To: apbugs@hyperreal.org
Subject: Compilation fails: wait() wants "union wait status" and some "redefinition" warnings
X-Send-Pr-Version: 3.2

>Number:         2516
>Category:       general
>Synopsis:       Compilation fails: wait() wants "union wait status" and some "redefinition" warnings
>Confidential:   no
>Severity:       serious
>Priority:       medium
>Responsible:    apache
>State:          closed
>Class:          change-request
>Submitter-Id:   apache
>Arrival-Date:   Sat Jun 27 06:50:00 PDT 1998
>Last-Modified:  Sun Jun 13 04:49:12 PDT 1999
>Originator:     nakaji@zeisei.dpri.kyoto-u.ac.jp
>Organization:
>Release:        1.3.0
>Environment:
/etc/motd
NEWS-OS Release 4.2.1R FCS#5 #13: Mon Sep  8 23:50:00 JST 1997
CC=gcc-2.7.2.3
>Description:
1. The prototype of my wait() is 
    int wait(union wait *status)
and all other wait(2) wants "union wait"
2. No WEXITSTATUS() and WTERMSIG().
3. "-DNEWSOS" causes some warnings. Because /usr/include/sys/newsos.h has definition of it. "-DNEWS4" is better. (No patch)
>How-To-Repeat:

>Fix:
An easy patch for the problem 1. and 2. is at http://zeisei3.dpri.kyoto-u.ac.jp/~nakaji/install/NEWS/net/ref/apache130.diff
>Audit-Trail:

From: =?iso-2022-jp?B?GyRCJEokKyQ4GyhC?= <nakaji@zeisei.dpri.kyoto-u.ac.jp>
To: apbugs@hyperreal.org, apache-bugdb@apache.org
Cc:  Subject: Re: general/2516: Compilation fails: wait() wants "union wait status" and some "redefinition" warnings
Date: Sun, 28 Jun 1998 11:58:01 +0900

 Dear maintainers,
 
 My easy patch I submitted last night (in Japan) is not
 good. I think Mr. Makoto Matsushita(matusita@ics.es.osaka-u.ac.jp)'s
 one is better. It is in
 
 ftp://ftp.ics.es.osaka-u.ac.jp/NEWS4aid/application-patches/apache-1.3.0.patch
 
 Please check. I hope NEWS-OS 4.x will be supported.
 
 Thanks in advance.
 ---
 NAKAJI Hiroyuki

From: Dean Gaudet <dgaudet@arctic.org>
To: =?iso-2022-jp?B?GyRCJEokKyQ4GyhC?= <nakaji@zeisei.dpri.kyoto-u.ac.jp>
Cc: matusita@ics.es.osaka-u.ac.jp, apbugs@apache.org
Subject: Re: general/2516: Compilation fails: wait() wants "union wait status" and some "redefinition" warnings
Date: Mon, 6 Jul 1998 20:47:13 -0700 (PDT)

 On 28 Jun 1998, [iso-2022-jp] なかじ wrote:
 
 >  My easy patch I submitted last night (in Japan) is not
 >  good. I think Mr. Makoto Matsushita(matusita@ics.es.osaka-u.ac.jp)'s
 >  one is better. It is in
 >  
 >  ftp://ftp.ics.es.osaka-u.ac.jp/NEWS4aid/application-patches/apache-1.3.0.patch
 
 That URL didn't work for me.
 
 In any event we've already had to fix a few things like this in 1.3.1-dev. 
 If one of you could pick up a snapshot at
 ftp://dev.apache.org/httpd/from-cvs/ and resubmit a patch that would be
 great. 
 
 Thanks
 Dean
 

From: Makoto MATSUSHITA (=?ISO-2022-JP?B?GyRCJF4kRCQ3JD8kXiQzJEgbKEI=?=) <matusita@ics.es.osaka-u.ac.jp>
To: dgaudet@arctic.org
Cc: nakaji@zeisei.dpri.kyoto-u.ac.jp, apbugs@apache.org
Subject: Re: general/2516: Compilation fails: wait() wants "union wait status" and some "redefinition" warnings
Date: Tue, 07 Jul 1998 13:13:16 +0900

 nakaji> ftp://ftp.ics.es.osaka-u.ac.jp/NEWS4aid/application-patches/apache-1.3.0.patch
 
 dgaudet> That URL didn't work for me.
 
 Not only for you, but also for everyone. Nakaji must say this URL:
 
 <URL:ftp://ftp.ics.es.osaka-u.ac.jp/pub/NEWS4aid/application-patches/apache-1.3.0.patch>
 
 This patch includes some functions come from libc of FreeBSD, which are
 not provided by the one of NEWS-OS 4.x; strftime(), mktime(). Is it O.K.?
 
 I'm also afraid that Apache 1.3.0 does not compile under old NEXTSTEP;
 the common point is 'a traditional 4.3BSD environment' (NEWS-OS 4.x
 comes from 4.3BSD, and more hacks by Sony).
 
 dgaudet> If one of you could pick up a snapshot at
 dgaudet> ftp://dev.apache.org/httpd/from-cvs/ and resubmit a patch
 dgaudet> that would be great.
 
 Sorry I have little time to do, but I'll try later...
 
 -- -
 Makoto `MAR' MATSUSHITA

From: =?iso-2022-jp?B?GyRCJEokKyQ4GyhC?= <nakaji@zeisei.dpri.kyoto-u.ac.jp>
To: dgaudet@arctic.org
Cc: matusita@ics.es.osaka-u.ac.jp, apbugs@apache.org
Subject: Re: general/2516: Compilation fails: wait() wants "union wait status" and some "redefinition" warnings
Date: Tue, 07 Jul 1998 13:51:11 +0900

 ----Next_Part(Tue_Jul__7_13:50:40_1998_443)--
 Content-Type: Text/Plain; charset=us-ascii
 Content-Transfer-Encoding: 7bit
 
 dgaudet> >  ftp://ftp.ics.es.osaka-u.ac.jp/NEWS4aid/application-patches/apache-1.3.0.patch
 dgaudet> 
 dgaudet> That URL didn't work for me.
 
 Sorry. The patch is attched to this mail.
 
 
 ----Next_Part(Tue_Jul__7_13:50:40_1998_443)--
 Content-Type: Text/Plain; charset=us-ascii
 Content-Transfer-Encoding: 7bit
 Content-Disposition: attachment; filename=apache-1.3.0.patch
 
 This is a patch for Apache 1.3.0, to compile on NEWS-OS 4.x.
 Be aware that this patch contains the sources which comes from FreeBSD.
 
 Author: matusita@ics.es.osaka-u.ac.jp, All rights reserved.
 
 --- src/Configure.dist	Tue May 12 21:13:50 1998
 +++ src/Configure	Fri Jun 26 22:09:46 1998
 @@ -655,10 +655,10 @@
  	OS='SEQUENT'
  	CFLAGS="$CFLAGS -DSEQUENT"
  	;;
 -    *NEWS-OS*)
 +    *-*-newsos4)
  	DEF_WANTHSREGEX=yes
 -	OS='SONY NEWS-OS'
 -	CFLAGS="$CFLAGS -DNEWSOS"
 +	OS='SONY NEWS-OS 4.x'
 +	CFLAGS="$CFLAGS -DNEWSOS4"
  	;;
      *-riscix)
  	OS='Acorn RISCix'
 --- src/helpers/GuessOS.dist	Sun Feb 22 00:00:41 1998
 +++ src/helpers/GuessOS	Thu Jun 25 11:37:05 1998
 @@ -233,6 +233,10 @@
  	echo "whatever-unisys-sysv4"; exit 0;
  	;;
  
 +    NEWS-OS:6.*:*:*)
 +	echo "${MACHINE}-sony-newsos6"; exit 0;
 +	;;
 +
  esac
  
  #
 @@ -245,6 +249,14 @@
  # enough
  if [ -d /usr/apollo ]; then
      echo "whatever-apollo-whatever"
 +    exit 0
 +fi
 +
 +# Next, check NEWS-OS 4.x. We have already checked out NEWS-OS 6.x,
 +# and we assume that there are no machines running NEWS-OS [1235].x.
 +if [ -d /usr/sony ]; then
 +    MACHINE=`(/usr/sony/bin/machine -m) 2>/dev/null` || MACHINE="unknown"
 +    echo "${MACHINE}-sony-newsos4"
      exit 0
  fi
  
 --- src/include/conf.h.dist	Fri May 29 09:15:56 1998
 +++ src/include/conf.h	Fri Jun 26 23:35:17 1998
 @@ -726,14 +726,18 @@
  #define USE_FCNTL_SERIALIZED_ACCEPT
  #define HAVE_SYSLOG 1
  
 -#elif defined(NEWSOS)
 +#elif defined(NEWSOS4)
  #define HAVE_SYS_RESOURCE_H 1
  #define HAVE_SHMGET 1
 +#define HAVE_GMTOFF 1
  #define USE_SHMGET_SCOREBOARD
  #define USE_LONGJMP
  #define NO_SETSID
  #define NO_USE_SIGACTION
 +#define NEED_DIFFTIME
  #define NEED_WAITPID
 +#define NEED_UNION_WAIT
 +#define NEED_STRFTIME
  #define NO_OTHER_CHILD
  #define HAVE_SYSLOG 1
  #include <sys/time.h>
 @@ -742,6 +746,7 @@
  typedef int pid_t;
  typedef int rlim_t;
  typedef int mode_t;
 +typedef int clock_t;
  
  #elif defined(RISCIX)
  #include <sys/time.h>
 @@ -963,6 +968,17 @@
  
  #ifndef INADDR_NONE
  #define INADDR_NONE ((unsigned long) -1)
 +#endif
 +
 +#if defined(NEED_UNION_WAIT) && defined(NEWSOS4)
 +#undef WIFEXITED
 +#undef WEXITSTATUS
 +#undef WIFSIGNALED
 +#define WIFEXITED(x) (((union wait)(x)).w_stopval != WSTOPPED && ((union wait)(x)).w_termsig == 0)
 +#define WEXITSTATUS(x) ((((union wait)(x)).w_status) & 0177)
 +#define WIFSIGNALED(x) (((union wait)(x)).w_stopval != WSTOPPED && ((union wait)(x)).w_termsig != 0)
 +#define WTERMSIG(x) (((union wait)(x)).w_termsig)
 +#define WCOREDUMP(x) (((union wait)(x)).w_coredump)
  #endif
  
  /*
 --- src/include/util_date.h.dist	Fri May 22 20:35:04 1998
 +++ src/include/util_date.h	Fri Jun 26 22:10:35 1998
 @@ -66,7 +66,7 @@
   * util_date.h: prototypes for date parsing utility routines
   */
  
 -#ifdef NEWSOS
 +#ifdef NEWSOS4
  #include <stdlib.h>
  #include <sys/types.h>
  #endif
 --- src/main/http_main.c.dist	Fri May 29 17:18:49 1998
 +++ src/main/http_main.c	Fri Jun 26 22:10:54 1998
 @@ -2629,7 +2629,7 @@
  	fprintf(stderr, "httpd: setsid failed\n");
  	exit(1);
      }
 -#elif defined(NEXT) || defined(NEWSOS)
 +#elif defined(NEXT) || defined(NEWSOS4)
      if (setpgrp(0, getpid()) == -1 || (pgrp = getpgrp(0)) == -1) {
  	perror("setpgrp");
  	fprintf(stderr, "httpd: setpgrp or getpgrp failed\n");
 --- src/main/util.c.dist	Tue Jun  2 03:20:30 1998
 +++ src/main/util.c	Sat Jun 27 21:32:20 1998
 @@ -1435,6 +1435,15 @@
   * this is not ideal but it works for SVR3 variants
   * httpd does not use the options so this doesn't implement them
   */
 +#ifdef NEED_UNION_WAIT
 +int waitpid(pid_t pid, int *statusp, int options)
 +{
 +    if (pid == -1)
 +	return wait3((union wait*)statusp, options, (struct rusage *)NULL);
 +    else
 +	return wait4(pid, (union wait *)statusp, options, (struct rusage *)NULL);
 +}
 +#else
  int waitpid(pid_t pid, int *statusp, int options)
  {
      int tmp_pid;
 @@ -1446,6 +1455,7 @@
      return tmp_pid;
  }
  #endif
 +#endif
  
  API_EXPORT(int) ap_ind(const char *s, char c)
  {
 @@ -1750,3 +1760,1140 @@
      return (time1 - time0);
  }
  #endif
 +
 +#if defined(NEED_STRFTIME)
 +/*
 + * Copyright (c) 1989 The Regents of the University of California.
 + * All rights reserved.
 + *
 + * Redistribution and use in source and binary forms are permitted
 + * provided that the above copyright notice and this paragraph are
 + * duplicated in all such forms and that any documentation,
 + * advertising materials, and other materials related to such
 + * distribution and use acknowledge that the software was developed
 + * by the University of California, Berkeley.  The name of the
 + * University may not be used to endorse or promote products derived
 + * from this software without specific prior written permission.
 + * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 + * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 + * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 + */
 +
 +#ifdef LIBC_RCS
 +static const char rcsid[] =
 +	"$Id: strftime.c,v 1.2.4.1 1995/08/28 05:07:03 davidg Exp $";
 +#endif
 +
 +#ifdef notdef
 +#ifndef lint
 +#ifndef NOID
 +static const char	elsieid[] = "@(#)strftime.c	7.38";
 +/*
 +** Based on the UCB version with the ID appearing below.
 +** This is ANSIish only when "multibyte character == plain character".
 +*/
 +#endif /* !defined NOID */
 +#endif /* !defined lint */
 +#endif
 +
 +#ifndef const
 +#ifndef __STDC__
 +#define const
 +#endif /* !defined __STDC__ */
 +#endif /* !defined const */
 +#ifndef P
 +#ifdef __STDC__
 +#define P(x)	x
 +#endif /* defined __STDC__ */
 +#ifndef __STDC__
 +#define P(x)	()
 +#endif /* !defined __STDC__ */
 +#endif /* !defined P */
 +#ifndef INT_STRLEN_MAXIMUM
 +/*
 +** 302 / 1000 is log10(2.0) rounded up.
 +** Subtract one for the sign bit;
 +** add one for integer division truncation;
 +** add one more for a minus sign.
 +*/
 +#define INT_STRLEN_MAXIMUM(type) \
 +	((sizeof(type) * CHAR_BIT - 1) * 302 / 1000 + 2)
 +#endif /* !defined INT_STRLEN_MAXIMUM */
 +
 +#ifndef LIBC_SCCS
 +#ifndef lint
 +static const char	sccsid[] = "@(#)strftime.c	5.4 (Berkeley) 3/14/89";
 +#endif /* !defined lint */
 +#endif /* !defined LIBC_SCCS */
 +
 +#include <stdio.h>
 +#include <tzfile.h>
 +#include <fcntl.h>
 +#include <time.h>
 +#include <limits.h>
 +#include <sys/types.h>
 +#include <sys/stat.h>
 +
 +/*
 +** redefine isleap() (defined in <tzfile.h>) to avoid warnings
 +*/
 +#undef isleap(y)
 +#define isleap(y) ((((y) % 4) == 0) && (((y) % 100) != 0) || (((y) % 400) == 0))
 +
 +#define LOCALE_HOME _PATH_LOCALE
 +
 +struct lc_time_T {
 +	const char *	mon[12];
 +	const char *	month[12];
 +	const char *	wday[7];
 +	const char *	weekday[7];
 +	const char *	X_fmt;
 +	const char *	x_fmt;
 +	const char *	c_fmt;
 +	const char *	am;
 +	const char *	pm;
 +	const char *	date_fmt;
 +};
 +
 +#define Locale	(&C_time_locale)
 +
 +static const struct lc_time_T	C_time_locale = {
 +	{
 +		"Jan", "Feb", "Mar", "Apr", "May", "Jun",
 +		"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
 +	}, {
 +		"January", "February", "March", "April", "May", "June",
 +		"July", "August", "September", "October", "November", "December"
 +	}, {
 +		"Sun", "Mon", "Tue", "Wed",
 +		"Thu", "Fri", "Sat"
 +	}, {
 +		"Sunday", "Monday", "Tuesday", "Wednesday",
 +		"Thursday", "Friday", "Saturday"
 +	},
 +
 +	/* X_fmt */
 +	"%H:%M:%S",
 +
 +	/*
 +	** x_fmt
 +	** Since the C language standard calls for
 +	** "date, using locale's date format," anything goes.
 +	** Using just numbers (as here) makes Quakers happier;
 +	** it's also compatible with SVR4.
 +	*/
 +	"%m/%d/%y",
 +
 +	/*
 +	** c_fmt (ctime-compatible)
 +	** Note that
 +	**	"%a %b %d %H:%M:%S %Y"
 +	** is used by Solaris 2.3.
 +	*/
 +	"%a %b %e %X %Y",
 +
 +	/* am */
 +	"AM",
 +
 +	/* pm */
 +	"PM",
 +
 +	/* date_fmt */
 +	"%a %b %e %X %Z %Y"
 +};
 +
 +static char *	_add P((const char *, char *, const char *));
 +static char *	_conv P((int, const char *, char *, const char *));
 +static char *	_fmt P((const char *, const struct tm *, char *, const char *));
 +static char *   _secs P((const struct tm *, char *, const char *));
 +
 +size_t strftime P((char *, size_t, const char *, const struct tm *));
 +
 +extern char *	tzname[];
 +
 +size_t
 +strftime(s, maxsize, format, t)
 +	char *const s;
 +	const size_t maxsize;
 +	const char *const format;
 +	const struct tm *const t;
 +{
 +	char *p;
 +
 +	tzset();
 +	p = _fmt(((format == NULL) ? "%c" : format), t, s, s + maxsize);
 +	if (p == s + maxsize)
 +		return 0;
 +	*p = '\0';
 +	return p - s;
 +}
 +
 +static char *
 +_fmt(format, t, pt, ptlim)
 +	const char *format;
 +	const struct tm *const t;
 +	char *pt;
 +	const char *const ptlim;
 +{
 +	for ( ; *format; ++format) {
 +		if (*format == '%') {
 +label:
 +			switch (*++format) {
 +			case '\0':
 +				--format;
 +				break;
 +			case 'A':
 +				pt = _add((t->tm_wday < 0 || t->tm_wday > 6) ?
 +					"?" : Locale->weekday[t->tm_wday],
 +					pt, ptlim);
 +				continue;
 +			case 'a':
 +				pt = _add((t->tm_wday < 0 || t->tm_wday > 6) ?
 +					"?" : Locale->wday[t->tm_wday],
 +					pt, ptlim);
 +				continue;
 +			case 'B':
 +				pt = _add((t->tm_mon < 0 || t->tm_mon > 11) ?
 +					"?" : Locale->month[t->tm_mon],
 +					pt, ptlim);
 +				continue;
 +			case 'b':
 +			case 'h':
 +				pt = _add((t->tm_mon < 0 || t->tm_mon > 11) ?
 +					"?" : Locale->mon[t->tm_mon],
 +					pt, ptlim);
 +				continue;
 +			case 'C':
 +				/*
 +				** %C used to do a...
 +				**	_fmt("%a %b %e %X %Y", t);
 +				** ...whereas now POSIX 1003.2 calls for
 +				** something completely different.
 +				** (ado, 5/24/93)
 +				*/
 +				pt = _conv((t->tm_year + TM_YEAR_BASE) / 100,
 +					"%02d", pt, ptlim);
 +				continue;
 +			case 'c':
 +				pt = _fmt(Locale->c_fmt, t, pt, ptlim);
 +				continue;
 +			case 'D':
 +				pt = _fmt("%m/%d/%y", t, pt, ptlim);
 +				continue;
 +			case 'd':
 +				pt = _conv(t->tm_mday, "%02d", pt, ptlim);
 +				continue;
 +			case 'E':
 +			case 'O':
 +				/*
 +				** POSIX locale extensions, a la
 +				** Arnold Robbins' strftime version 3.0.
 +				** The sequences
 +				**	%Ec %EC %Ex %Ey %EY
 +				**	%Od %oe %OH %OI %Om %OM
 +				**	%OS %Ou %OU %OV %Ow %OW %Oy
 +				** are supposed to provide alternate
 +				** representations.
 +				** (ado, 5/24/93)
 +				*/
 +				goto label;
 +			case 'e':
 +				pt = _conv(t->tm_mday, "%2d", pt, ptlim);
 +				continue;
 +			case 'H':
 +				pt = _conv(t->tm_hour, "%02d", pt, ptlim);
 +				continue;
 +			case 'I':
 +				pt = _conv((t->tm_hour % 12) ?
 +					(t->tm_hour % 12) : 12,
 +					"%02d", pt, ptlim);
 +				continue;
 +			case 'j':
 +				pt = _conv(t->tm_yday + 1, "%03d", pt, ptlim);
 +				continue;
 +			case 'k':
 +				/*
 +				** This used to be...
 +				**	_conv(t->tm_hour % 12 ?
 +				**		t->tm_hour % 12 : 12, 2, ' ');
 +				** ...and has been changed to the below to
 +				** match SunOS 4.1.1 and Arnold Robbins'
 +				** strftime version 3.0.  That is, "%k" and
 +				** "%l" have been swapped.
 +				** (ado, 5/24/93)
 +				*/
 +				pt = _conv(t->tm_hour, "%2d", pt, ptlim);
 +				continue;
 +#ifdef KITCHEN_SINK
 +			case 'K':
 +				/*
 +				** After all this time, still unclaimed!
 +				*/
 +				pt = _add("kitchen sink", pt, ptlim);
 +				continue;
 +#endif /* defined KITCHEN_SINK */
 +			case 'l':
 +				/*
 +				** This used to be...
 +				**	_conv(t->tm_hour, 2, ' ');
 +				** ...and has been changed to the below to
 +				** match SunOS 4.1.1 and Arnold Robbin's
 +				** strftime version 3.0.  That is, "%k" and
 +				** "%l" have been swapped.
 +				** (ado, 5/24/93)
 +				*/
 +				pt = _conv((t->tm_hour % 12) ?
 +					(t->tm_hour % 12) : 12,
 +					"%2d", pt, ptlim);
 +				continue;
 +			case 'M':
 +				pt = _conv(t->tm_min, "%02d", pt, ptlim);
 +				continue;
 +			case 'm':
 +				pt = _conv(t->tm_mon + 1, "%02d", pt, ptlim);
 +				continue;
 +			case 'n':
 +				pt = _add("\n", pt, ptlim);
 +				continue;
 +			case 'p':
 +				pt = _add((t->tm_hour >= 12) ?
 +					Locale->pm :
 +					Locale->am,
 +					pt, ptlim);
 +				continue;
 +			case 'R':
 +				pt = _fmt("%H:%M", t, pt, ptlim);
 +				continue;
 +			case 'r':
 +				pt = _fmt("%I:%M:%S %p", t, pt, ptlim);
 +				continue;
 +			case 'S':
 +				pt = _conv(t->tm_sec, "%02d", pt, ptlim);
 +				continue;
 +			case 's':
 +				pt = _secs(t, pt, ptlim);
 +				continue;
 +			case 'T':
 +				pt = _fmt("%H:%M:%S", t, pt, ptlim);
 +				continue;
 +			case 't':
 +				pt = _add("\t", pt, ptlim);
 +				continue;
 +			case 'U':
 +				pt = _conv((t->tm_yday + 7 - t->tm_wday) / 7,
 +					"%02d", pt, ptlim);
 +				continue;
 +			case 'u':
 +				/*
 +				** From Arnold Robbins' strftime version 3.0:
 +				** "ISO 8601: Weekday as a decimal number
 +				** [1 (Monday) - 7]"
 +				** (ado, 5/24/93)
 +				*/
 +				pt = _conv((t->tm_wday == 0) ? 7 : t->tm_wday,
 +					"%d", pt, ptlim);
 +				continue;
 +			case 'V':
 +				/*
 +				** From Arnold Robbins' strftime version 3.0:
 +				** "the week number of the year (the first
 +				** Monday as the first day of week 1) as a
 +				** decimal number (01-53).  The method for
 +				** determining the week number is as specified
 +				** by ISO 8601 (to wit: if the week containing
 +				** January 1 has four or more days in the new
 +				** year, then it is week 1, otherwise it is
 +				** week 53 of the previous year and the next
 +				** week is week 1)."
 +				** (ado, 5/24/93)
 +				*/
 +				/*
 +				** XXX--If January 1 falls on a Friday,
 +				** January 1-3 are part of week 53 of the
 +				** previous year.  By analogy, if January
 +				** 1 falls on a Thursday, are December 29-31
 +				** of the PREVIOUS year part of week 1???
 +				** (ado 5/24/93)
 +				*/
 +				/*
 +				** You are understood not to expect this.
 +				*/
 +				{
 +					int	i;
 +
 +					i = (t->tm_yday + 10 - (t->tm_wday ?
 +						(t->tm_wday - 1) : 6)) / 7;
 +					if (i == 0) {
 +						/*
 +						** What day of the week does
 +						** January 1 fall on?
 +						*/
 +						i = t->tm_wday -
 +							(t->tm_yday - 1);
 +						/*
 +						** Fri Jan 1: 53
 +						** Sun Jan 1: 52
 +						** Sat Jan 1: 53 if previous
 +						**		 year a leap
 +						**		 year, else 52
 +						*/
 +						if (i == TM_FRIDAY)
 +							i = 53;
 +						else if (i == TM_SUNDAY)
 +							i = 52;
 +						else	i = isleap(t->tm_year +
 +								TM_YEAR_BASE) ?
 +								53 : 52;
 +#ifdef XPG4_1994_04_09
 +						/*
 +						** As of 4/9/94, though,
 +						** XPG4 calls for 53
 +						** unconditionally.
 +						*/
 +						i = 53;
 +#endif /* defined XPG4_1994_04_09 */
 +					}
 +					pt = _conv(i, "%02d", pt, ptlim);
 +				}
 +				continue;
 +			case 'v':
 +				/*
 +				** From Arnold Robbins' strftime version 3.0:
 +				** "date as dd-bbb-YYYY"
 +				** (ado, 5/24/93)
 +				*/
 +				pt = _fmt("%e-%b-%Y", t, pt, ptlim);
 +				continue;
 +			case 'W':
 +				pt = _conv((t->tm_yday + 7 -
 +					(t->tm_wday ?
 +					(t->tm_wday - 1) : 6)) / 7,
 +					"%02d", pt, ptlim);
 +				continue;
 +			case 'w':
 +				pt = _conv(t->tm_wday, "%d", pt, ptlim);
 +				continue;
 +			case 'X':
 +				pt = _fmt(Locale->X_fmt, t, pt, ptlim);
 +				continue;
 +			case 'x':
 +				pt = _fmt(Locale->x_fmt, t, pt, ptlim);
 +				continue;
 +			case 'y':
 +				pt = _conv((t->tm_year + TM_YEAR_BASE) % 100,
 +					"%02d", pt, ptlim);
 +				continue;
 +			case 'Y':
 +				pt = _conv(t->tm_year + TM_YEAR_BASE, "%04d",
 +					pt, ptlim);
 +				continue;
 +			case 'Z':
 +				if (t->tm_zone != NULL)
 +					pt = _add(t->tm_zone, pt, ptlim);
 +				else
 +				if (t->tm_isdst == 0 || t->tm_isdst == 1) {
 +					pt = _add(tzname[t->tm_isdst],
 +						pt, ptlim);
 +				} else  pt = _add("?", pt, ptlim);
 +				continue;
 +			case '+':
 +				pt = _fmt(Locale->date_fmt, t, pt, ptlim);
 +				continue;
 +			case '%':
 +			/*
 +			 * X311J/88-090 (4.12.3.5): if conversion char is
 +			 * undefined, behavior is undefined.  Print out the
 +			 * character itself as printf(3) also does.
 +			 */
 +			default:
 +				break;
 +			}
 +		}
 +		if (pt == ptlim)
 +			break;
 +		*pt++ = *format;
 +	}
 +	return pt;
 +}
 +
 +static char *
 +_conv(n, format, pt, ptlim)
 +	const int n;
 +	const char *const format;
 +	char *const pt;
 +	const char *const ptlim;
 +{
 +	char	buf[INT_STRLEN_MAXIMUM(int) + 1];
 +
 +	(void) sprintf(buf, format, n);
 +	return _add(buf, pt, ptlim);
 +}
 +
 +static char *
 +_secs(t, pt, ptlim)
 +	const struct tm *t;
 +	char *pt;
 +	const char *ptlim;
 +{
 +	char    buf[INT_STRLEN_MAXIMUM(int) + 1];
 +	register time_t s;
 +	struct tm tmp;
 +
 +	/* Make a copy, mktime(3) modifies the tm struct. */
 +	tmp = *t;
 +	s = mktime(&tmp);
 +	(void) sprintf(buf, "%ld", s);
 +	return _add(buf, pt, ptlim);
 +}
 +  
 +static char *
 +_add(str, pt, ptlim)
 +	const char *str;
 +	char *pt;
 +	const char *const ptlim;
 +{
 +	while (pt < ptlim && (*pt = *str++) != '\0')
 +		++pt;
 +	return pt;
 +}
 +#endif
 +
 +#ifndef lint
 +#ifndef NOID
 +static char	elsieid[] = "@(#)localtime.c	7.44";
 +#endif /* !defined NOID */
 +#endif /* !defined lint */
 +
 +/*
 +** Leap second handling from Bradley White (bww@k.gp.cs.cmu.edu).
 +** POSIX-style TZ environment variable handling from Guy Harris
 +** (guy@auspex.com).
 +*/
 +
 +/*LINTLIBRARY*/
 +
 +#ifndef const
 +#ifndef __STDC__
 +#define const
 +#endif /* !defined __STDC__ */
 +#endif /* !defined const */
 +#ifndef P
 +#ifdef __STDC__
 +#define P(x)	x
 +#endif /* defined __STDC__ */
 +#ifndef __STDC__
 +#define P(x)	()
 +#endif /* !defined __STDC__ */
 +#endif /* !defined P */
 +#define FILENAME_MAX    MAXPATHLEN
 +#ifndef TRUE
 +#define TRUE	1
 +#endif /* !defined TRUE */
 +#ifndef FALSE
 +#define FALSE	1
 +#endif /* !defined FALSE */
 +
 +/* #include <sys/param.h> */
 +#include <sys/types.h>
 +#include <sys/stat.h>
 +
 +/*
 +** redefine isleap() (defined in <tzfile.h>) to avoid warnings
 +*/
 +#undef isleap(y)
 +#define isleap(y) ((((y) % 4) == 0) && (((y) % 100) != 0) || (((y) % 400) == 0))
 +
 +/*
 +** SunOS 4.1.1 headers lack O_BINARY.
 +*/
 +
 +#ifdef O_BINARY
 +#define OPEN_MODE	(O_RDONLY | O_BINARY)
 +#endif /* defined O_BINARY */
 +#ifndef O_BINARY
 +#define OPEN_MODE	O_RDONLY
 +#endif /* !defined O_BINARY */
 +
 +#ifndef WILDABBR
 +/*
 +** Someone might make incorrect use of a time zone abbreviation:
 +**	1.	They might reference tzname[0] before calling tzset (explicitly
 +**		or implicitly).
 +**	2.	They might reference tzname[1] before calling tzset (explicitly
 +**		or implicitly).
 +**	3.	They might reference tzname[1] after setting to a time zone
 +**		in which Daylight Saving Time is never observed.
 +**	4.	They might reference tzname[0] after setting to a time zone
 +**		in which Standard Time is never observed.
 +**	5.	They might reference tm.TM_ZONE after calling offtime.
 +** What's best to do in the above cases is open to debate;
 +** for now, we just set things up so that in any of the five cases
 +** WILDABBR is used.  Another possibility:  initialize tzname[0] to the
 +** string "tzname[0] used before set", and similarly for the other cases.
 +** And another:  initialize tzname[0] to "ERA", with an explanation in the
 +** manual page of what this "time zone abbreviation" means (doing this so
 +** that tzname[0] has the "normal" length of three characters).
 +*/
 +#define WILDABBR	"   "
 +#endif /* !defined WILDABBR */
 +
 +static const char	gmt[] = "GMT";
 +
 +struct ttinfo {				/* time type information */
 +	long		tt_gmtoff;	/* GMT offset in seconds */
 +	int		tt_isdst;	/* used to set tm_isdst */
 +	int		tt_abbrind;	/* abbreviation list index */
 +	int		tt_ttisstd;	/* TRUE if transition is std time */
 +	int		tt_ttisgmt;	/* TRUE if transition is GMT */
 +};
 +
 +struct lsinfo {				/* leap second information */
 +	time_t		ls_trans;	/* transition time */
 +	long		ls_corr;	/* correction to apply */
 +};
 +
 +#define BIGGEST(a, b)	(((a) > (b)) ? (a) : (b))
 +
 +#ifdef TZNAME_MAX
 +#define MY_TZNAME_MAX	TZNAME_MAX
 +#endif /* defined TZNAME_MAX */
 +#ifndef TZNAME_MAX
 +#define MY_TZNAME_MAX	255
 +#endif /* !defined TZNAME_MAX */
 +
 +struct state {
 +	int		leapcnt;
 +	int		timecnt;
 +	int		typecnt;
 +	int		charcnt;
 +	time_t		ats[TZ_MAX_TIMES];
 +	unsigned char	types[TZ_MAX_TIMES];
 +	struct ttinfo	ttis[TZ_MAX_TYPES];
 +	char		chars[(2 * (MY_TZNAME_MAX + 1))];
 +	struct lsinfo	lsis[TZ_MAX_LEAPS];
 +};
 +
 +struct rule {
 +	int		r_type;		/* type of rule--see below */
 +	int		r_day;		/* day number of rule */
 +	int		r_week;		/* week number of rule */
 +	int		r_mon;		/* month number of rule */
 +	long		r_time;		/* transition time of rule */
 +};
 +
 +#define JULIAN_DAY		0	/* Jn - Julian day */
 +#define DAY_OF_YEAR		1	/* n - day of year */
 +#define MONTH_NTH_DAY_OF_WEEK	2	/* Mm.n.d - month, week, day of week */
 +
 +/*
 +** Prototypes for static functions.
 +*/
 +
 +static void		localsub P((const time_t * timep, long offset,
 +				struct tm * tmp));
 +static int		increment_overflow P((int * number, int delta));
 +static int		normalize_overflow P((int * tensptr, int * unitsptr,
 +				int base));
 +static time_t		time1 P((struct tm * tmp,
 +				void(*funcp) P((const time_t *,
 +				long, struct tm *)),
 +				long offset));
 +static time_t		time2 P((struct tm *tmp,
 +				void(*funcp) P((const time_t *,
 +				long, struct tm*)),
 +				long offset, int * okayp));
 +static void		timesub P((const time_t * timep, long offset,
 +				const struct state * sp, struct tm * tmp));
 +static int		tmcomp P((const struct tm * atmp,
 +				const struct tm * btmp));
 +
 +#ifdef ALL_STATE
 +static struct state *	lclptr;
 +static struct state *	gmtptr;
 +#endif /* defined ALL_STATE */
 +
 +#ifndef ALL_STATE
 +static struct state	lclmem;
 +static struct state	gmtmem;
 +#define lclptr		(&lclmem)
 +#define gmtptr		(&gmtmem)
 +#endif /* State Farm */
 +
 +#ifndef TZ_STRLEN_MAX
 +#define TZ_STRLEN_MAX 255
 +#endif /* !defined TZ_STRLEN_MAX */
 +
 +extern char *		tzname[2];
 +
 +static const int	mon_lengths[2][MONSPERYEAR] = {
 +	{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
 +	{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
 +};
 +
 +static const int	year_lengths[2] = {
 +	DAYSPERNYEAR, DAYSPERLYEAR
 +};
 +
 +/*
 +** The easy way to behave "as if no library function calls" localtime
 +** is to not call it--so we drop its guts into "localsub", which can be
 +** freely called.  (And no, the PANS doesn't require the above behavior--
 +** but it *is* desirable.)
 +**
 +** The unused offset argument is for the benefit of mktime variants.
 +*/
 +
 +/*ARGSUSED*/
 +static void
 +localsub(timep, offset, tmp)
 +const time_t * const	timep;
 +const long		offset;
 +struct tm * const	tmp;
 +{
 +	register struct state *		sp;
 +	register const struct ttinfo *	ttisp;
 +	register int			i;
 +	const time_t			t = *timep;
 +
 +	sp = lclptr;
 +#ifdef ALL_STATE
 +	if (sp == NULL) {
 +		gmtsub(timep, offset, tmp);
 +		return;
 +	}
 +#endif /* defined ALL_STATE */
 +	if (sp->timecnt == 0 || t < sp->ats[0]) {
 +		i = 0;
 +		while (sp->ttis[i].tt_isdst)
 +			if (++i >= sp->typecnt) {
 +				i = 0;
 +				break;
 +			}
 +	} else {
 +		for (i = 1; i < sp->timecnt; ++i)
 +			if (t < sp->ats[i])
 +				break;
 +		i = sp->types[i - 1];
 +	}
 +	ttisp = &sp->ttis[i];
 +	/*
 +	** To get (wrong) behavior that's compatible with System V Release 2.0
 +	** you'd replace the statement below with
 +	**	t += ttisp->tt_gmtoff;
 +	**	timesub(&t, 0L, sp, tmp);
 +	*/
 +	timesub(&t, ttisp->tt_gmtoff, sp, tmp);
 +	tmp->tm_isdst = ttisp->tt_isdst;
 +	tzname[tmp->tm_isdst] = &sp->chars[ttisp->tt_abbrind];
 +#ifdef TM_ZONE
 +	tmp->TM_ZONE = &sp->chars[ttisp->tt_abbrind];
 +#endif /* defined TM_ZONE */
 +}
 +
 +static void
 +timesub(timep, offset, sp, tmp)
 +const time_t * const			timep;
 +const long				offset;
 +register const struct state * const	sp;
 +register struct tm * const		tmp;
 +{
 +	register const struct lsinfo *	lp;
 +	register long			days;
 +	register long			rem;
 +	register int			y;
 +	register int			yleap;
 +	register const int *		ip;
 +	register long			corr;
 +	register int			hit;
 +	register int			i;
 +
 +	corr = 0;
 +	hit = 0;
 +#ifdef ALL_STATE
 +	i = (sp == NULL) ? 0 : sp->leapcnt;
 +#endif /* defined ALL_STATE */
 +#ifndef ALL_STATE
 +	i = sp->leapcnt;
 +#endif /* State Farm */
 +	while (--i >= 0) {
 +		lp = &sp->lsis[i];
 +		if (*timep >= lp->ls_trans) {
 +			if (*timep == lp->ls_trans) {
 +				hit = ((i == 0 && lp->ls_corr > 0) ||
 +					lp->ls_corr > sp->lsis[i - 1].ls_corr);
 +				if (hit)
 +					while (i > 0 &&
 +						sp->lsis[i].ls_trans ==
 +						sp->lsis[i - 1].ls_trans + 1 &&
 +						sp->lsis[i].ls_corr ==
 +						sp->lsis[i - 1].ls_corr + 1) {
 +							++hit;
 +							--i;
 +					}
 +			}
 +			corr = lp->ls_corr;
 +			break;
 +		}
 +	}
 +	days = *timep / SECSPERDAY;
 +	rem = *timep % SECSPERDAY;
 +#ifdef mc68k
 +	if (*timep == 0x80000000) {
 +		/*
 +		** A 3B1 muffs the division on the most negative number.
 +		*/
 +		days = -24855;
 +		rem = -11648;
 +	}
 +#endif /* defined mc68k */
 +	rem += (offset - corr);
 +	while (rem < 0) {
 +		rem += SECSPERDAY;
 +		--days;
 +	}
 +	while (rem >= SECSPERDAY) {
 +		rem -= SECSPERDAY;
 +		++days;
 +	}
 +	tmp->tm_hour = (int) (rem / SECSPERHOUR);
 +	rem = rem % SECSPERHOUR;
 +	tmp->tm_min = (int) (rem / SECSPERMIN);
 +	tmp->tm_sec = (int) (rem % SECSPERMIN);
 +	if (hit)
 +		/*
 +		** A positive leap second requires a special
 +		** representation.  This uses "... ??:59:60" et seq.
 +		*/
 +		tmp->tm_sec += hit;
 +	tmp->tm_wday = (int) ((EPOCH_WDAY + days) % DAYSPERWEEK);
 +	if (tmp->tm_wday < 0)
 +		tmp->tm_wday += DAYSPERWEEK;
 +	y = EPOCH_YEAR;
 +	if (days >= 0)
 +		for ( ; ; ) {
 +			yleap = isleap(y);
 +			if (days < (long) year_lengths[yleap])
 +				break;
 +			++y;
 +			days = days - (long) year_lengths[yleap];
 +		}
 +	else do {
 +		--y;
 +		yleap = isleap(y);
 +		days = days + (long) year_lengths[yleap];
 +	} while (days < 0);
 +	tmp->tm_year = y - TM_YEAR_BASE;
 +	tmp->tm_yday = (int) days;
 +	ip = mon_lengths[yleap];
 +	for (tmp->tm_mon = 0; days >= (long) ip[tmp->tm_mon]; ++(tmp->tm_mon))
 +		days = days - (long) ip[tmp->tm_mon];
 +	tmp->tm_mday = (int) (days + 1);
 +	tmp->tm_isdst = 0;
 +#ifdef TM_GMTOFF
 +	tmp->TM_GMTOFF = offset;
 +#endif /* defined TM_GMTOFF */
 +}
 +
 +/*
 +** Adapted from code provided by Robert Elz, who writes:
 +**	The "best" way to do mktime I think is based on an idea of Bob
 +**	Kridle's (so its said...) from a long time ago. (mtxinu!kridle now).
 +**	It does a binary search of the time_t space.  Since time_t's are
 +**	just 32 bits, its a max of 32 iterations (even at 64 bits it
 +**	would still be very reasonable).
 +*/
 +
 +#ifndef WRONG
 +#define WRONG	(-1)
 +#endif /* !defined WRONG */
 +
 +/*
 +** Simplified normalize logic courtesy Paul Eggert (eggert@twinsun.com).
 +*/
 +
 +static int
 +increment_overflow(number, delta)
 +int *	number;
 +int	delta;
 +{
 +	int	number0;
 +
 +	number0 = *number;
 +	*number += delta;
 +	return (*number < number0) != (delta < 0);
 +}
 +
 +static int
 +normalize_overflow(tensptr, unitsptr, base)
 +int * const	tensptr;
 +int * const	unitsptr;
 +const int	base;
 +{
 +	register int	tensdelta;
 +
 +	tensdelta = (*unitsptr >= 0) ?
 +		(*unitsptr / base) :
 +		(-1 - (-1 - *unitsptr) / base);
 +	*unitsptr -= tensdelta * base;
 +	return increment_overflow(tensptr, tensdelta);
 +}
 +
 +static int
 +tmcomp(atmp, btmp)
 +register const struct tm * const atmp;
 +register const struct tm * const btmp;
 +{
 +	register int	result;
 +
 +	if ((result = (atmp->tm_year - btmp->tm_year)) == 0 &&
 +		(result = (atmp->tm_mon - btmp->tm_mon)) == 0 &&
 +		(result = (atmp->tm_mday - btmp->tm_mday)) == 0 &&
 +		(result = (atmp->tm_hour - btmp->tm_hour)) == 0 &&
 +		(result = (atmp->tm_min - btmp->tm_min)) == 0)
 +			result = atmp->tm_sec - btmp->tm_sec;
 +	return result;
 +}
 +
 +static time_t
 +time2(tmp, funcp, offset, okayp)
 +struct tm * const	tmp;
 +void (* const		funcp) P((const time_t*, long, struct tm*));
 +const long		offset;
 +int * const		okayp;
 +{
 +	register const struct state *	sp;
 +	register int			dir;
 +	register int			bits;
 +	register int			i, j ;
 +	register int			saved_seconds;
 +	time_t				newt;
 +	time_t				t;
 +	struct tm			yourtm, mytm;
 +
 +	*okayp = FALSE;
 +	yourtm = *tmp;
 +	if (normalize_overflow(&yourtm.tm_hour, &yourtm.tm_min, MINSPERHOUR))
 +		return WRONG;
 +	if (normalize_overflow(&yourtm.tm_mday, &yourtm.tm_hour, HOURSPERDAY))
 +		return WRONG;
 +	if (normalize_overflow(&yourtm.tm_year, &yourtm.tm_mon, MONSPERYEAR))
 +		return WRONG;
 +	/*
 +	** Turn yourtm.tm_year into an actual year number for now.
 +	** It is converted back to an offset from TM_YEAR_BASE later.
 +	*/
 +	if (increment_overflow(&yourtm.tm_year, TM_YEAR_BASE))
 +		return WRONG;
 +	while (yourtm.tm_mday <= 0) {
 +		if (increment_overflow(&yourtm.tm_year, -1))
 +			return WRONG;
 +		yourtm.tm_mday += year_lengths[isleap(yourtm.tm_year)];
 +	}
 +	while (yourtm.tm_mday > DAYSPERLYEAR) {
 +		yourtm.tm_mday -= year_lengths[isleap(yourtm.tm_year)];
 +		if (increment_overflow(&yourtm.tm_year, 1))
 +			return WRONG;
 +	}
 +	for ( ; ; ) {
 +		i = mon_lengths[isleap(yourtm.tm_year)][yourtm.tm_mon];
 +		if (yourtm.tm_mday <= i)
 +			break;
 +		yourtm.tm_mday -= i;
 +		if (++yourtm.tm_mon >= MONSPERYEAR) {
 +			yourtm.tm_mon = 0;
 +			if (increment_overflow(&yourtm.tm_year, 1))
 +				return WRONG;
 +		}
 +	}
 +	if (increment_overflow(&yourtm.tm_year, -TM_YEAR_BASE))
 +		return WRONG;
 +	if (yourtm.tm_year + TM_YEAR_BASE < EPOCH_YEAR) {
 +		/*
 +		** We can't set tm_sec to 0, because that might push the
 +		** time below the minimum representable time.
 +		** Set tm_sec to 59 instead.
 +		** This assumes that the minimum representable time is
 +		** not in the same minute that a leap second was deleted from,
 +		** which is a safer assumption than using 58 would be.
 +		*/
 +		if (increment_overflow(&yourtm.tm_sec, 1 - SECSPERMIN))
 +			return WRONG;
 +		saved_seconds = yourtm.tm_sec;
 +		yourtm.tm_sec = SECSPERMIN - 1;
 +	} else {
 +		saved_seconds = yourtm.tm_sec;
 +		yourtm.tm_sec = 0;
 +	}
 +	/*
 +	** Calculate the number of magnitude bits in a time_t
 +	** (this works regardless of whether time_t is
 +	** signed or unsigned, though lint complains if unsigned).
 +	*/
 +	for (bits = 0, t = 1; t > 0; ++bits, t <<= 1)
 +		continue;
 +	/*
 +	** If time_t is signed, then 0 is the median value,
 +	** if time_t is unsigned, then 1 << bits is median.
 +	*/
 +	t = (t < 0) ? 0 : ((time_t) 1 << bits);
 +	for ( ; ; ) {
 +		(*funcp)(&t, offset, &mytm);
 +		dir = tmcomp(&mytm, &yourtm);
 +		if (dir != 0) {
 +			if (bits-- < 0)
 +				return WRONG;
 +			if (bits < 0)
 +				--t;
 +			else if (dir > 0)
 +				t -= (time_t) 1 << bits;
 +			else	t += (time_t) 1 << bits;
 +			continue;
 +		}
 +		if (yourtm.tm_isdst < 0 || mytm.tm_isdst == yourtm.tm_isdst)
 +			break;
 +		/*
 +		** Right time, wrong type.
 +		** Hunt for right time, right type.
 +		** It's okay to guess wrong since the guess
 +		** gets checked.
 +		*/
 +		/*
 +		** The (void *) casts are the benefit of SunOS 3.3 on Sun 2's.
 +		*/
 +		sp = (const struct state *)
 +			(((void *) funcp == (void *) localsub) ?
 +			lclptr : gmtptr);
 +#ifdef ALL_STATE
 +		if (sp == NULL)
 +			return WRONG;
 +#endif /* defined ALL_STATE */
 +		for (i = 0; i < sp->typecnt; ++i) {
 +			if (sp->ttis[i].tt_isdst != yourtm.tm_isdst)
 +				continue;
 +			for (j = 0; j < sp->typecnt; ++j) {
 +				if (sp->ttis[j].tt_isdst == yourtm.tm_isdst)
 +					continue;
 +				newt = t + sp->ttis[j].tt_gmtoff -
 +					sp->ttis[i].tt_gmtoff;
 +				(*funcp)(&newt, offset, &mytm);
 +				if (tmcomp(&mytm, &yourtm) != 0)
 +					continue;
 +				if (mytm.tm_isdst != yourtm.tm_isdst)
 +					continue;
 +				/*
 +				** We have a match.
 +				*/
 +				t = newt;
 +				goto label;
 +			}
 +		}
 +		return WRONG;
 +	}
 +label:
 +	newt = t + saved_seconds;
 +	if ((newt < t) != (saved_seconds < 0))
 +		return WRONG;
 +	t = newt;
 +	(*funcp)(&t, offset, tmp);
 +	*okayp = TRUE;
 +	return t;
 +}
 +
 +static time_t
 +time1(tmp, funcp, offset)
 +struct tm * const	tmp;
 +void (* const		funcp) P((const time_t*, long, struct tm*));
 +const long		offset;
 +{
 +	register time_t			t;
 +	register const struct state *	sp;
 +	register int			samei, otheri;
 +	int				okay;
 +
 +	if (tmp->tm_isdst > 1)
 +		tmp->tm_isdst = 1;
 +	t = time2(tmp, funcp, offset, &okay);
 +#ifdef PCTS
 +	/*
 +	** PCTS code courtesy Grant Sullivan (grant@osf.org).
 +	*/
 +	if (okay)
 +		return t;
 +	if (tmp->tm_isdst < 0)
 +		tmp->tm_isdst = 0;	/* reset to std and try again */
 +#endif /* defined PCTS */
 +#ifndef PCTS
 +	if (okay || tmp->tm_isdst < 0)
 +		return t;
 +#endif /* !defined PCTS */
 +	/*
 +	** We're supposed to assume that somebody took a time of one type
 +	** and did some math on it that yielded a "struct tm" that's bad.
 +	** We try to divine the type they started from and adjust to the
 +	** type they need.
 +	*/
 +	/*
 +	** The (void *) casts are the benefit of SunOS 3.3 on Sun 2's.
 +	*/
 +	sp = (const struct state *) (((void *) funcp == (void *) localsub) ?
 +		lclptr : gmtptr);
 +#ifdef ALL_STATE
 +	if (sp == NULL)
 +		return WRONG;
 +#endif /* defined ALL_STATE */
 +	for (samei = 0; samei < sp->typecnt; ++samei) {
 +		if (sp->ttis[samei].tt_isdst != tmp->tm_isdst)
 +			continue;
 +		for (otheri = 0; otheri < sp->typecnt; ++otheri) {
 +			if (sp->ttis[otheri].tt_isdst == tmp->tm_isdst)
 +				continue;
 +			tmp->tm_sec += sp->ttis[otheri].tt_gmtoff -
 +					sp->ttis[samei].tt_gmtoff;
 +			tmp->tm_isdst = !tmp->tm_isdst;
 +			t = time2(tmp, funcp, offset, &okay);
 +			if (okay)
 +				return t;
 +			tmp->tm_sec -= sp->ttis[otheri].tt_gmtoff -
 +					sp->ttis[samei].tt_gmtoff;
 +			tmp->tm_isdst = !tmp->tm_isdst;
 +		}
 +	}
 +	return WRONG;
 +}
 +
 +time_t
 +mktime(tmp)
 +struct tm * const	tmp;
 +{
 +	tzset();
 +	return time1(tmp, localsub, 0L);
 +}
 +
 +#ifdef STD_INSPIRED
 +
 +time_t
 +timelocal(tmp)
 +struct tm * const	tmp;
 +{
 +	tmp->tm_isdst = -1;	/* in case it wasn't initialized */
 +	return mktime(tmp);
 +}
 +
 +time_t
 +timegm(tmp)
 +struct tm * const	tmp;
 +{
 +	tmp->tm_isdst = 0;
 +	return time1(tmp, gmtsub, 0L);
 +}
 +
 +time_t
 +timeoff(tmp, offset)
 +struct tm * const	tmp;
 +const long		offset;
 +{
 +	tmp->tm_isdst = 0;
 +	return time1(tmp, gmtsub, offset);
 +}
 +
 +#endif /* defined STD_INSPIRED */
 --- src/modules/proxy/proxy_cache.c.dist	Sat May 30 03:20:58 1998
 +++ src/modules/proxy/proxy_cache.c	Sat Jun 27 21:58:20 1998
 @@ -64,7 +64,11 @@
  #ifdef WIN32
  #include <sys/utime.h>
  #else
 +#ifdef NEWSOS4
 +#include <sys/types.h>
 +#else
  #include <utime.h>
 +#endif /* NEWSOS4 */
  #endif /* WIN32 */
  #include "multithread.h"
  #include "ap_md5.h"
 --- src/modules/standard/mod_mime_magic.c.dist	Fri May 29 07:09:57 1998
 +++ src/modules/standard/mod_mime_magic.c	Sat Jun 27 21:55:15 1998
 @@ -130,7 +130,11 @@
  #include "http_log.h"
  #include "http_protocol.h"
  
 +#if defined(NEWSOS4)
 +#include <sys/types.h>
 +#else
  #include <utime.h>
 +#endif
  
  
  /*
 --- src/modules/standard/mod_status.c.dist	Wed May  6 12:24:20 1998
 +++ src/modules/standard/mod_status.c	Fri Jun 26 22:35:24 1998
 @@ -130,6 +130,10 @@
  #endif
  #endif
  
 +#if defined(NEWSOS4)
 +#include <machine/machparam.h>
 +#endif
 +
  #define STATUS_MAXLINE		64
  
  #define KBYTE			1024
 @@ -232,6 +236,8 @@
      long req_time;
  #if defined(NEXT)
      float tick = HZ;
 +#elif defined(NEWSOS4)
 +    float tick=CLK_TCK;
  #elif !defined(WIN32)
      float tick = sysconf(_SC_CLK_TCK);
  #endif
 
 ----Next_Part(Tue_Jul__7_13:50:40_1998_443)----

From: Makoto MATSUSHITA (=?ISO-2022-JP?B?GyRCJF4kRCQ3JD8kXiQzJEgbKEI=?=) <matusita@ics.es.osaka-u.ac.jp>
To: dgaudet@arctic.org
Cc: nakaji@zeisei.dpri.kyoto-u.ac.jp, apbugs@apache.org
Subject: Re: general/2516: Compilation fails: wait() wants "union wait status" and some "redefinition" warnings
Date: Tue, 07 Jul 1998 17:04:27 +0900

 dgaudet> In any event we've already had to fix a few things like this
 dgaudet> in 1.3.1-dev.  If one of you could pick up a snapshot at
 dgaudet> ftp://dev.apache.org/httpd/from-cvs/ and resubmit a patch
 dgaudet> that would be great.
 
 I reworked a patch, to port exactly/only for NEWS-OS 4.2.
 
 It is not a port for NEWS-OS 4.[01] (because some more function such
 as strcmp, strdup, etc are missing to compile Apache), nor NEWS-OS
 [56].x (however, I make a room to port to these OSes; I avoid to use
 the name of 'NEWSOS', it's too generic.) Porting NEWS-OS 6.x may be
 easy, 'cause it comes from SVR4.
 
 Well, this is a patch, comes from apache_19980707010029.tar.gz.
 
 -- -
 Makoto `MAR' MATSUSHITA
 
 --- src/Configure.dist	Mon Jul  6 22:00:10 1998
 +++ src/Configure	Tue Jul  7 16:38:16 1998
 @@ -677,10 +677,10 @@
  	OS='SEQUENT'
  	CFLAGS="$CFLAGS -DSEQUENT"
  	;;
 -    *NEWS-OS*)
 +    *-*-newsos42)
  	DEF_WANTHSREGEX=yes
 -	OS='SONY NEWS-OS'
 -	CFLAGS="$CFLAGS -DNEWSOS"
 +	OS='SONY NEWS-OS 4.2'
 +	CFLAGS="$CFLAGS -DNEWSOS42"
  	;;
      *-riscix)
  	OS='Acorn RISCix'
 --- src/helpers/GuessOS.dist	Mon Jun 29 22:00:11 1998
 +++ src/helpers/GuessOS	Tue Jul  7 16:50:11 1998
 @@ -231,6 +231,14 @@
  	echo "whatever-unisys-sysv4"; exit 0;
  	;;
  
 +    NEWS-OS:5.*:*:*)
 +	echo "${MACHINE}-sony-newsos5"; exit 0;
 +	;;
 +
 +    NEWS-OS:6.*:*:*)
 +	echo "${MACHINE}-sony-newsos6"; exit 0;
 +	;;
 +
  esac
  
  #
 @@ -243,6 +251,16 @@
  # enough
  if [ -d /usr/apollo ]; then
      echo "whatever-apollo-whatever"
 +    exit 0
 +fi
 +
 +# Next, check NEWS-OS 4.x or before. We assume the existence of <sys/newsos.h>,
 +# and the definition of NEWSOS_MAJOR/NEWSOS_MINOR...
 +if [ -d /usr/sony ]; then
 +    MACHINE=`(/usr/sony/bin/machine -m) 2>/dev/null` || MACHINE="unknown"
 +    MAJOR=`grep define /usr/include/sys/newsos.h | awk '$2 == "NEWSOS_MAJOR" {print $3}'`
 +    MINOR=`grep define /usr/include/sys/newsos.h | awk '$2 == "NEWSOS_MINOR" {print $3}'`
 +    echo "${MACHINE}-sony-newsos${MAJOR}${MINOR}"
      exit 0
  fi
  
 --- src/include/conf.h.dist	Sat Jun 20 22:00:13 1998
 +++ src/include/conf.h	Tue Jul  7 16:34:53 1998
 @@ -744,14 +744,19 @@
  #define USE_FCNTL_SERIALIZED_ACCEPT
  #define HAVE_SYSLOG 1
  
 -#elif defined(NEWSOS)
 +#elif defined(NEWSOS42)
  #define HAVE_SYS_RESOURCE_H 1
  #define HAVE_SHMGET 1
 +#define HAVE_GMTOFF 1
  #define USE_SHMGET_SCOREBOARD
  #define USE_LONGJMP
  #define NO_SETSID
  #define NO_USE_SIGACTION
 +#define NEED_DIFFTIME
 +#define NEED_MKTIME
 +#define NEED_STRFTIME
  #define NEED_WAITPID
 +#define NEED_UNION_WAIT
  #define NO_OTHER_CHILD
  #define HAVE_SYSLOG 1
  #include <sys/time.h>
 @@ -760,6 +765,7 @@
  typedef int pid_t;
  typedef int rlim_t;
  typedef int mode_t;
 +typedef int clock_t;
  
  #elif defined(RISCIX)
  #include <sys/time.h>
 @@ -981,6 +987,17 @@
  
  #ifndef INADDR_NONE
  #define INADDR_NONE ((unsigned long) -1)
 +#endif
 +
 +#if defined(NEED_UNION_WAIT) && defined(NEWSOS42)
 +#undef WIFEXITED
 +#undef WEXITSTATUS
 +#undef WIFSIGNALED
 +#define WIFEXITED(x) (((union wait)(x)).w_stopval != WSTOPPED && ((union wait)(x)).w_termsig == 0)
 +#define WEXITSTATUS(x) ((((union wait)(x)).w_status) & 0177)
 +#define WIFSIGNALED(x) (((union wait)(x)).w_stopval != WSTOPPED && ((union wait)(x)).w_termsig != 0)
 +#define WTERMSIG(x) (((union wait)(x)).w_termsig)
 +#define WCOREDUMP(x) (((union wait)(x)).w_coredump)
  #endif
  
  /*
 --- src/include/util_date.h.dist	Fri May 22 22:00:11 1998
 +++ src/include/util_date.h	Tue Jul  7 16:36:15 1998
 @@ -66,7 +66,7 @@
   * util_date.h: prototypes for date parsing utility routines
   */
  
 -#ifdef NEWSOS
 +#ifdef NEWSOS42
  #include <stdlib.h>
  #include <sys/types.h>
  #endif
 --- src/main/http_main.c.dist	Mon Jun 29 22:00:13 1998
 +++ src/main/http_main.c	Tue Jul  7 16:36:28 1998
 @@ -2640,7 +2640,7 @@
  	fprintf(stderr, "httpd: setsid failed\n");
  	exit(1);
      }
 -#elif defined(NEXT) || defined(NEWSOS)
 +#elif defined(NEXT) || defined(NEWSOS42)
      if (setpgrp(0, getpid()) == -1 || (pgrp = getpgrp(0)) == -1) {
  	perror("setpgrp");
  	fprintf(stderr, "httpd: setpgrp or getpgrp failed\n");
 --- src/main/util.c.dist	Sat Jun 20 10:00:13 1998
 +++ src/main/util.c	Tue Jul  7 14:47:06 1998
 @@ -1464,6 +1464,15 @@
   * Modified by dwd@bell-labs.com to call wait3 instead of wait because
   *   apache started to use the WNOHANG option.
   */
 +#ifdef NEED_UNION_WAIT
 +int waitpid(pid_t pid, int *statusp, int options)
 +{
 +    if (pid == -1)
 +	return wait3((union wait*)statusp, options, (struct rusage *)NULL);
 +    else
 +	return wait4(pid, (union wait *)statusp, options, (struct rusage *)NULL);
 +}
 +#else
  int waitpid(pid_t pid, int *statusp, int options)
  {
      int tmp_pid;
 @@ -1477,6 +1486,7 @@
      return tmp_pid;
  }
  #endif
 +#endif
  
  API_EXPORT(int) ap_ind(const char *s, char c)
  {
 @@ -1780,6 +1790,1145 @@
  {
      return (time1 - time0);
  }
 +#endif
 +
 +#if defined(NEED_STRFTIME)
 +/*
 + * Copyright (c) 1989 The Regents of the University of California.
 + * All rights reserved.
 + *
 + * Redistribution and use in source and binary forms are permitted
 + * provided that the above copyright notice and this paragraph are
 + * duplicated in all such forms and that any documentation,
 + * advertising materials, and other materials related to such
 + * distribution and use acknowledge that the software was developed
 + * by the University of California, Berkeley.  The name of the
 + * University may not be used to endorse or promote products derived
 + * from this software without specific prior written permission.
 + * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 + * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 + * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 + */
 +
 +#ifdef LIBC_RCS
 +static const char rcsid[] =
 +	"$Id: strftime.c,v 1.2.4.1 1995/08/28 05:07:03 davidg Exp $";
 +#endif
 +
 +#ifdef notdef
 +#ifndef lint
 +#ifndef NOID
 +static const char	elsieid[] = "@(#)strftime.c	7.38";
 +/*
 +** Based on the UCB version with the ID appearing below.
 +** This is ANSIish only when "multibyte character == plain character".
 +*/
 +#endif /* !defined NOID */
 +#endif /* !defined lint */
 +#endif
 +
 +#ifndef const
 +#ifndef __STDC__
 +#define const
 +#endif /* !defined __STDC__ */
 +#endif /* !defined const */
 +#ifndef P
 +#ifdef __STDC__
 +#define P(x)	x
 +#endif /* defined __STDC__ */
 +#ifndef __STDC__
 +#define P(x)	()
 +#endif /* !defined __STDC__ */
 +#endif /* !defined P */
 +#ifndef INT_STRLEN_MAXIMUM
 +/*
 +** 302 / 1000 is log10(2.0) rounded up.
 +** Subtract one for the sign bit;
 +** add one for integer division truncation;
 +** add one more for a minus sign.
 +*/
 +#define INT_STRLEN_MAXIMUM(type) \
 +	((sizeof(type) * CHAR_BIT - 1) * 302 / 1000 + 2)
 +#endif /* !defined INT_STRLEN_MAXIMUM */
 +
 +#ifndef LIBC_SCCS
 +#ifndef lint
 +static const char	sccsid[] = "@(#)strftime.c	5.4 (Berkeley) 3/14/89";
 +#endif /* !defined lint */
 +#endif /* !defined LIBC_SCCS */
 +
 +#include <stdio.h>
 +#include <tzfile.h>
 +#include <fcntl.h>
 +#include <time.h>
 +#include <limits.h>
 +#include <sys/types.h>
 +#include <sys/stat.h>
 +
 +/*
 +** redefine isleap() (defined in <tzfile.h>) to avoid warnings
 +*/
 +#undef isleap(y)
 +#define isleap(y) ((((y) % 4) == 0) && (((y) % 100) != 0) || (((y) % 400) == 0))
 +
 +#define LOCALE_HOME _PATH_LOCALE
 +
 +struct lc_time_T {
 +	const char *	mon[12];
 +	const char *	month[12];
 +	const char *	wday[7];
 +	const char *	weekday[7];
 +	const char *	X_fmt;
 +	const char *	x_fmt;
 +	const char *	c_fmt;
 +	const char *	am;
 +	const char *	pm;
 +	const char *	date_fmt;
 +};
 +
 +#define Locale	(&C_time_locale)
 +
 +static const struct lc_time_T	C_time_locale = {
 +	{
 +		"Jan", "Feb", "Mar", "Apr", "May", "Jun",
 +		"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
 +	}, {
 +		"January", "February", "March", "April", "May", "June",
 +		"July", "August", "September", "October", "November", "December"
 +	}, {
 +		"Sun", "Mon", "Tue", "Wed",
 +		"Thu", "Fri", "Sat"
 +	}, {
 +		"Sunday", "Monday", "Tuesday", "Wednesday",
 +		"Thursday", "Friday", "Saturday"
 +	},
 +
 +	/* X_fmt */
 +	"%H:%M:%S",
 +
 +	/*
 +	** x_fmt
 +	** Since the C language standard calls for
 +	** "date, using locale's date format," anything goes.
 +	** Using just numbers (as here) makes Quakers happier;
 +	** it's also compatible with SVR4.
 +	*/
 +	"%m/%d/%y",
 +
 +	/*
 +	** c_fmt (ctime-compatible)
 +	** Note that
 +	**	"%a %b %d %H:%M:%S %Y"
 +	** is used by Solaris 2.3.
 +	*/
 +	"%a %b %e %X %Y",
 +
 +	/* am */
 +	"AM",
 +
 +	/* pm */
 +	"PM",
 +
 +	/* date_fmt */
 +	"%a %b %e %X %Z %Y"
 +};
 +
 +static char *	_add P((const char *, char *, const char *));
 +static char *	_conv P((int, const char *, char *, const char *));
 +static char *	_fmt P((const char *, const struct tm *, char *, const char *));
 +static char *   _secs P((const struct tm *, char *, const char *));
 +
 +size_t strftime P((char *, size_t, const char *, const struct tm *));
 +
 +extern char *	tzname[];
 +
 +size_t
 +strftime(s, maxsize, format, t)
 +	char *const s;
 +	const size_t maxsize;
 +	const char *const format;
 +	const struct tm *const t;
 +{
 +	char *p;
 +
 +	tzset();
 +	p = _fmt(((format == NULL) ? "%c" : format), t, s, s + maxsize);
 +	if (p == s + maxsize)
 +		return 0;
 +	*p = '\0';
 +	return p - s;
 +}
 +
 +static char *
 +_fmt(format, t, pt, ptlim)
 +	const char *format;
 +	const struct tm *const t;
 +	char *pt;
 +	const char *const ptlim;
 +{
 +	for ( ; *format; ++format) {
 +		if (*format == '%') {
 +label:
 +			switch (*++format) {
 +			case '\0':
 +				--format;
 +				break;
 +			case 'A':
 +				pt = _add((t->tm_wday < 0 || t->tm_wday > 6) ?
 +					"?" : Locale->weekday[t->tm_wday],
 +					pt, ptlim);
 +				continue;
 +			case 'a':
 +				pt = _add((t->tm_wday < 0 || t->tm_wday > 6) ?
 +					"?" : Locale->wday[t->tm_wday],
 +					pt, ptlim);
 +				continue;
 +			case 'B':
 +				pt = _add((t->tm_mon < 0 || t->tm_mon > 11) ?
 +					"?" : Locale->month[t->tm_mon],
 +					pt, ptlim);
 +				continue;
 +			case 'b':
 +			case 'h':
 +				pt = _add((t->tm_mon < 0 || t->tm_mon > 11) ?
 +					"?" : Locale->mon[t->tm_mon],
 +					pt, ptlim);
 +				continue;
 +			case 'C':
 +				/*
 +				** %C used to do a...
 +				**	_fmt("%a %b %e %X %Y", t);
 +				** ...whereas now POSIX 1003.2 calls for
 +				** something completely different.
 +				** (ado, 5/24/93)
 +				*/
 +				pt = _conv((t->tm_year + TM_YEAR_BASE) / 100,
 +					"%02d", pt, ptlim);
 +				continue;
 +			case 'c':
 +				pt = _fmt(Locale->c_fmt, t, pt, ptlim);
 +				continue;
 +			case 'D':
 +				pt = _fmt("%m/%d/%y", t, pt, ptlim);
 +				continue;
 +			case 'd':
 +				pt = _conv(t->tm_mday, "%02d", pt, ptlim);
 +				continue;
 +			case 'E':
 +			case 'O':
 +				/*
 +				** POSIX locale extensions, a la
 +				** Arnold Robbins' strftime version 3.0.
 +				** The sequences
 +				**	%Ec %EC %Ex %Ey %EY
 +				**	%Od %oe %OH %OI %Om %OM
 +				**	%OS %Ou %OU %OV %Ow %OW %Oy
 +				** are supposed to provide alternate
 +				** representations.
 +				** (ado, 5/24/93)
 +				*/
 +				goto label;
 +			case 'e':
 +				pt = _conv(t->tm_mday, "%2d", pt, ptlim);
 +				continue;
 +			case 'H':
 +				pt = _conv(t->tm_hour, "%02d", pt, ptlim);
 +				continue;
 +			case 'I':
 +				pt = _conv((t->tm_hour % 12) ?
 +					(t->tm_hour % 12) : 12,
 +					"%02d", pt, ptlim);
 +				continue;
 +			case 'j':
 +				pt = _conv(t->tm_yday + 1, "%03d", pt, ptlim);
 +				continue;
 +			case 'k':
 +				/*
 +				** This used to be...
 +				**	_conv(t->tm_hour % 12 ?
 +				**		t->tm_hour % 12 : 12, 2, ' ');
 +				** ...and has been changed to the below to
 +				** match SunOS 4.1.1 and Arnold Robbins'
 +				** strftime version 3.0.  That is, "%k" and
 +				** "%l" have been swapped.
 +				** (ado, 5/24/93)
 +				*/
 +				pt = _conv(t->tm_hour, "%2d", pt, ptlim);
 +				continue;
 +#ifdef KITCHEN_SINK
 +			case 'K':
 +				/*
 +				** After all this time, still unclaimed!
 +				*/
 +				pt = _add("kitchen sink", pt, ptlim);
 +				continue;
 +#endif /* defined KITCHEN_SINK */
 +			case 'l':
 +				/*
 +				** This used to be...
 +				**	_conv(t->tm_hour, 2, ' ');
 +				** ...and has been changed to the below to
 +				** match SunOS 4.1.1 and Arnold Robbin's
 +				** strftime version 3.0.  That is, "%k" and
 +				** "%l" have been swapped.
 +				** (ado, 5/24/93)
 +				*/
 +				pt = _conv((t->tm_hour % 12) ?
 +					(t->tm_hour % 12) : 12,
 +					"%2d", pt, ptlim);
 +				continue;
 +			case 'M':
 +				pt = _conv(t->tm_min, "%02d", pt, ptlim);
 +				continue;
 +			case 'm':
 +				pt = _conv(t->tm_mon + 1, "%02d", pt, ptlim);
 +				continue;
 +			case 'n':
 +				pt = _add("\n", pt, ptlim);
 +				continue;
 +			case 'p':
 +				pt = _add((t->tm_hour >= 12) ?
 +					Locale->pm :
 +					Locale->am,
 +					pt, ptlim);
 +				continue;
 +			case 'R':
 +				pt = _fmt("%H:%M", t, pt, ptlim);
 +				continue;
 +			case 'r':
 +				pt = _fmt("%I:%M:%S %p", t, pt, ptlim);
 +				continue;
 +			case 'S':
 +				pt = _conv(t->tm_sec, "%02d", pt, ptlim);
 +				continue;
 +			case 's':
 +				pt = _secs(t, pt, ptlim);
 +				continue;
 +			case 'T':
 +				pt = _fmt("%H:%M:%S", t, pt, ptlim);
 +				continue;
 +			case 't':
 +				pt = _add("\t", pt, ptlim);
 +				continue;
 +			case 'U':
 +				pt = _conv((t->tm_yday + 7 - t->tm_wday) / 7,
 +					"%02d", pt, ptlim);
 +				continue;
 +			case 'u':
 +				/*
 +				** From Arnold Robbins' strftime version 3.0:
 +				** "ISO 8601: Weekday as a decimal number
 +				** [1 (Monday) - 7]"
 +				** (ado, 5/24/93)
 +				*/
 +				pt = _conv((t->tm_wday == 0) ? 7 : t->tm_wday,
 +					"%d", pt, ptlim);
 +				continue;
 +			case 'V':
 +				/*
 +				** From Arnold Robbins' strftime version 3.0:
 +				** "the week number of the year (the first
 +				** Monday as the first day of week 1) as a
 +				** decimal number (01-53).  The method for
 +				** determining the week number is as specified
 +				** by ISO 8601 (to wit: if the week containing
 +				** January 1 has four or more days in the new
 +				** year, then it is week 1, otherwise it is
 +				** week 53 of the previous year and the next
 +				** week is week 1)."
 +				** (ado, 5/24/93)
 +				*/
 +				/*
 +				** XXX--If January 1 falls on a Friday,
 +				** January 1-3 are part of week 53 of the
 +				** previous year.  By analogy, if January
 +				** 1 falls on a Thursday, are December 29-31
 +				** of the PREVIOUS year part of week 1???
 +				** (ado 5/24/93)
 +				*/
 +				/*
 +				** You are understood not to expect this.
 +				*/
 +				{
 +					int	i;
 +
 +					i = (t->tm_yday + 10 - (t->tm_wday ?
 +						(t->tm_wday - 1) : 6)) / 7;
 +					if (i == 0) {
 +						/*
 +						** What day of the week does
 +						** January 1 fall on?
 +						*/
 +						i = t->tm_wday -
 +							(t->tm_yday - 1);
 +						/*
 +						** Fri Jan 1: 53
 +						** Sun Jan 1: 52
 +						** Sat Jan 1: 53 if previous
 +						**		 year a leap
 +						**		 year, else 52
 +						*/
 +						if (i == TM_FRIDAY)
 +							i = 53;
 +						else if (i == TM_SUNDAY)
 +							i = 52;
 +						else	i = isleap(t->tm_year +
 +								TM_YEAR_BASE) ?
 +								53 : 52;
 +#ifdef XPG4_1994_04_09
 +						/*
 +						** As of 4/9/94, though,
 +						** XPG4 calls for 53
 +						** unconditionally.
 +						*/
 +						i = 53;
 +#endif /* defined XPG4_1994_04_09 */
 +					}
 +					pt = _conv(i, "%02d", pt, ptlim);
 +				}
 +				continue;
 +			case 'v':
 +				/*
 +				** From Arnold Robbins' strftime version 3.0:
 +				** "date as dd-bbb-YYYY"
 +				** (ado, 5/24/93)
 +				*/
 +				pt = _fmt("%e-%b-%Y", t, pt, ptlim);
 +				continue;
 +			case 'W':
 +				pt = _conv((t->tm_yday + 7 -
 +					(t->tm_wday ?
 +					(t->tm_wday - 1) : 6)) / 7,
 +					"%02d", pt, ptlim);
 +				continue;
 +			case 'w':
 +				pt = _conv(t->tm_wday, "%d", pt, ptlim);
 +				continue;
 +			case 'X':
 +				pt = _fmt(Locale->X_fmt, t, pt, ptlim);
 +				continue;
 +			case 'x':
 +				pt = _fmt(Locale->x_fmt, t, pt, ptlim);
 +				continue;
 +			case 'y':
 +				pt = _conv((t->tm_year + TM_YEAR_BASE) % 100,
 +					"%02d", pt, ptlim);
 +				continue;
 +			case 'Y':
 +				pt = _conv(t->tm_year + TM_YEAR_BASE, "%04d",
 +					pt, ptlim);
 +				continue;
 +			case 'Z':
 +				if (t->tm_zone != NULL)
 +					pt = _add(t->tm_zone, pt, ptlim);
 +				else
 +				if (t->tm_isdst == 0 || t->tm_isdst == 1) {
 +					pt = _add(tzname[t->tm_isdst],
 +						pt, ptlim);
 +				} else  pt = _add("?", pt, ptlim);
 +				continue;
 +			case '+':
 +				pt = _fmt(Locale->date_fmt, t, pt, ptlim);
 +				continue;
 +			case '%':
 +			/*
 +			 * X311J/88-090 (4.12.3.5): if conversion char is
 +			 * undefined, behavior is undefined.  Print out the
 +			 * character itself as printf(3) also does.
 +			 */
 +			default:
 +				break;
 +			}
 +		}
 +		if (pt == ptlim)
 +			break;
 +		*pt++ = *format;
 +	}
 +	return pt;
 +}
 +
 +static char *
 +_conv(n, format, pt, ptlim)
 +	const int n;
 +	const char *const format;
 +	char *const pt;
 +	const char *const ptlim;
 +{
 +	char	buf[INT_STRLEN_MAXIMUM(int) + 1];
 +
 +	(void) sprintf(buf, format, n);
 +	return _add(buf, pt, ptlim);
 +}
 +
 +static char *
 +_secs(t, pt, ptlim)
 +	const struct tm *t;
 +	char *pt;
 +	const char *ptlim;
 +{
 +	char    buf[INT_STRLEN_MAXIMUM(int) + 1];
 +	register time_t s;
 +	struct tm tmp;
 +
 +	/* Make a copy, mktime(3) modifies the tm struct. */
 +	tmp = *t;
 +	s = mktime(&tmp);
 +	(void) sprintf(buf, "%ld", s);
 +	return _add(buf, pt, ptlim);
 +}
 +  
 +static char *
 +_add(str, pt, ptlim)
 +	const char *str;
 +	char *pt;
 +	const char *const ptlim;
 +{
 +	while (pt < ptlim && (*pt = *str++) != '\0')
 +		++pt;
 +	return pt;
 +}
 +#endif
 +
 +#ifdef NEED_MKTIME
 +#ifndef lint
 +#ifndef NOID
 +static char	elsieid[] = "@(#)localtime.c	7.44";
 +#endif /* !defined NOID */
 +#endif /* !defined lint */
 +
 +/*
 +** Leap second handling from Bradley White (bww@k.gp.cs.cmu.edu).
 +** POSIX-style TZ environment variable handling from Guy Harris
 +** (guy@auspex.com).
 +*/
 +
 +/*LINTLIBRARY*/
 +
 +#ifndef const
 +#ifndef __STDC__
 +#define const
 +#endif /* !defined __STDC__ */
 +#endif /* !defined const */
 +#ifndef P
 +#ifdef __STDC__
 +#define P(x)	x
 +#endif /* defined __STDC__ */
 +#ifndef __STDC__
 +#define P(x)	()
 +#endif /* !defined __STDC__ */
 +#endif /* !defined P */
 +#define FILENAME_MAX    MAXPATHLEN
 +#ifndef TRUE
 +#define TRUE	1
 +#endif /* !defined TRUE */
 +#ifndef FALSE
 +#define FALSE	1
 +#endif /* !defined FALSE */
 +
 +/* #include <sys/param.h> */
 +#include <sys/types.h>
 +#include <sys/stat.h>
 +
 +/*
 +** redefine isleap() (defined in <tzfile.h>) to avoid warnings
 +*/
 +#undef isleap(y)
 +#define isleap(y) ((((y) % 4) == 0) && (((y) % 100) != 0) || (((y) % 400) == 0))
 +
 +/*
 +** SunOS 4.1.1 headers lack O_BINARY.
 +*/
 +
 +#ifdef O_BINARY
 +#define OPEN_MODE	(O_RDONLY | O_BINARY)
 +#endif /* defined O_BINARY */
 +#ifndef O_BINARY
 +#define OPEN_MODE	O_RDONLY
 +#endif /* !defined O_BINARY */
 +
 +#ifndef WILDABBR
 +/*
 +** Someone might make incorrect use of a time zone abbreviation:
 +**	1.	They might reference tzname[0] before calling tzset (explicitly
 +**		or implicitly).
 +**	2.	They might reference tzname[1] before calling tzset (explicitly
 +**		or implicitly).
 +**	3.	They might reference tzname[1] after setting to a time zone
 +**		in which Daylight Saving Time is never observed.
 +**	4.	They might reference tzname[0] after setting to a time zone
 +**		in which Standard Time is never observed.
 +**	5.	They might reference tm.TM_ZONE after calling offtime.
 +** What's best to do in the above cases is open to debate;
 +** for now, we just set things up so that in any of the five cases
 +** WILDABBR is used.  Another possibility:  initialize tzname[0] to the
 +** string "tzname[0] used before set", and similarly for the other cases.
 +** And another:  initialize tzname[0] to "ERA", with an explanation in the
 +** manual page of what this "time zone abbreviation" means (doing this so
 +** that tzname[0] has the "normal" length of three characters).
 +*/
 +#define WILDABBR	"   "
 +#endif /* !defined WILDABBR */
 +
 +static const char	gmt[] = "GMT";
 +
 +struct ttinfo {				/* time type information */
 +	long		tt_gmtoff;	/* GMT offset in seconds */
 +	int		tt_isdst;	/* used to set tm_isdst */
 +	int		tt_abbrind;	/* abbreviation list index */
 +	int		tt_ttisstd;	/* TRUE if transition is std time */
 +	int		tt_ttisgmt;	/* TRUE if transition is GMT */
 +};
 +
 +struct lsinfo {				/* leap second information */
 +	time_t		ls_trans;	/* transition time */
 +	long		ls_corr;	/* correction to apply */
 +};
 +
 +#define BIGGEST(a, b)	(((a) > (b)) ? (a) : (b))
 +
 +#ifdef TZNAME_MAX
 +#define MY_TZNAME_MAX	TZNAME_MAX
 +#endif /* defined TZNAME_MAX */
 +#ifndef TZNAME_MAX
 +#define MY_TZNAME_MAX	255
 +#endif /* !defined TZNAME_MAX */
 +
 +struct state {
 +	int		leapcnt;
 +	int		timecnt;
 +	int		typecnt;
 +	int		charcnt;
 +	time_t		ats[TZ_MAX_TIMES];
 +	unsigned char	types[TZ_MAX_TIMES];
 +	struct ttinfo	ttis[TZ_MAX_TYPES];
 +	char		chars[(2 * (MY_TZNAME_MAX + 1))];
 +	struct lsinfo	lsis[TZ_MAX_LEAPS];
 +};
 +
 +struct rule {
 +	int		r_type;		/* type of rule--see below */
 +	int		r_day;		/* day number of rule */
 +	int		r_week;		/* week number of rule */
 +	int		r_mon;		/* month number of rule */
 +	long		r_time;		/* transition time of rule */
 +};
 +
 +#define JULIAN_DAY		0	/* Jn - Julian day */
 +#define DAY_OF_YEAR		1	/* n - day of year */
 +#define MONTH_NTH_DAY_OF_WEEK	2	/* Mm.n.d - month, week, day of week */
 +
 +/*
 +** Prototypes for static functions.
 +*/
 +
 +static void		localsub P((const time_t * timep, long offset,
 +				struct tm * tmp));
 +static int		increment_overflow P((int * number, int delta));
 +static int		normalize_overflow P((int * tensptr, int * unitsptr,
 +				int base));
 +static time_t		time1 P((struct tm * tmp,
 +				void(*funcp) P((const time_t *,
 +				long, struct tm *)),
 +				long offset));
 +static time_t		time2 P((struct tm *tmp,
 +				void(*funcp) P((const time_t *,
 +				long, struct tm*)),
 +				long offset, int * okayp));
 +static void		timesub P((const time_t * timep, long offset,
 +				const struct state * sp, struct tm * tmp));
 +static int		tmcomp P((const struct tm * atmp,
 +				const struct tm * btmp));
 +
 +#ifdef ALL_STATE
 +static struct state *	lclptr;
 +static struct state *	gmtptr;
 +#endif /* defined ALL_STATE */
 +
 +#ifndef ALL_STATE
 +static struct state	lclmem;
 +static struct state	gmtmem;
 +#define lclptr		(&lclmem)
 +#define gmtptr		(&gmtmem)
 +#endif /* State Farm */
 +
 +#ifndef TZ_STRLEN_MAX
 +#define TZ_STRLEN_MAX 255
 +#endif /* !defined TZ_STRLEN_MAX */
 +
 +extern char *		tzname[2];
 +
 +static const int	mon_lengths[2][MONSPERYEAR] = {
 +	{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
 +	{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
 +};
 +
 +static const int	year_lengths[2] = {
 +	DAYSPERNYEAR, DAYSPERLYEAR
 +};
 +
 +/*
 +** The easy way to behave "as if no library function calls" localtime
 +** is to not call it--so we drop its guts into "localsub", which can be
 +** freely called.  (And no, the PANS doesn't require the above behavior--
 +** but it *is* desirable.)
 +**
 +** The unused offset argument is for the benefit of mktime variants.
 +*/
 +
 +/*ARGSUSED*/
 +static void
 +localsub(timep, offset, tmp)
 +const time_t * const	timep;
 +const long		offset;
 +struct tm * const	tmp;
 +{
 +	register struct state *		sp;
 +	register const struct ttinfo *	ttisp;
 +	register int			i;
 +	const time_t			t = *timep;
 +
 +	sp = lclptr;
 +#ifdef ALL_STATE
 +	if (sp == NULL) {
 +		gmtsub(timep, offset, tmp);
 +		return;
 +	}
 +#endif /* defined ALL_STATE */
 +	if (sp->timecnt == 0 || t < sp->ats[0]) {
 +		i = 0;
 +		while (sp->ttis[i].tt_isdst)
 +			if (++i >= sp->typecnt) {
 +				i = 0;
 +				break;
 +			}
 +	} else {
 +		for (i = 1; i < sp->timecnt; ++i)
 +			if (t < sp->ats[i])
 +				break;
 +		i = sp->types[i - 1];
 +	}
 +	ttisp = &sp->ttis[i];
 +	/*
 +	** To get (wrong) behavior that's compatible with System V Release 2.0
 +	** you'd replace the statement below with
 +	**	t += ttisp->tt_gmtoff;
 +	**	timesub(&t, 0L, sp, tmp);
 +	*/
 +	timesub(&t, ttisp->tt_gmtoff, sp, tmp);
 +	tmp->tm_isdst = ttisp->tt_isdst;
 +	tzname[tmp->tm_isdst] = &sp->chars[ttisp->tt_abbrind];
 +#ifdef TM_ZONE
 +	tmp->TM_ZONE = &sp->chars[ttisp->tt_abbrind];
 +#endif /* defined TM_ZONE */
 +}
 +
 +static void
 +timesub(timep, offset, sp, tmp)
 +const time_t * const			timep;
 +const long				offset;
 +register const struct state * const	sp;
 +register struct tm * const		tmp;
 +{
 +	register const struct lsinfo *	lp;
 +	register long			days;
 +	register long			rem;
 +	register int			y;
 +	register int			yleap;
 +	register const int *		ip;
 +	register long			corr;
 +	register int			hit;
 +	register int			i;
 +
 +	corr = 0;
 +	hit = 0;
 +#ifdef ALL_STATE
 +	i = (sp == NULL) ? 0 : sp->leapcnt;
 +#endif /* defined ALL_STATE */
 +#ifndef ALL_STATE
 +	i = sp->leapcnt;
 +#endif /* State Farm */
 +	while (--i >= 0) {
 +		lp = &sp->lsis[i];
 +		if (*timep >= lp->ls_trans) {
 +			if (*timep == lp->ls_trans) {
 +				hit = ((i == 0 && lp->ls_corr > 0) ||
 +					lp->ls_corr > sp->lsis[i - 1].ls_corr);
 +				if (hit)
 +					while (i > 0 &&
 +						sp->lsis[i].ls_trans ==
 +						sp->lsis[i - 1].ls_trans + 1 &&
 +						sp->lsis[i].ls_corr ==
 +						sp->lsis[i - 1].ls_corr + 1) {
 +							++hit;
 +							--i;
 +					}
 +			}
 +			corr = lp->ls_corr;
 +			break;
 +		}
 +	}
 +	days = *timep / SECSPERDAY;
 +	rem = *timep % SECSPERDAY;
 +#ifdef mc68k
 +	if (*timep == 0x80000000) {
 +		/*
 +		** A 3B1 muffs the division on the most negative number.
 +		*/
 +		days = -24855;
 +		rem = -11648;
 +	}
 +#endif /* defined mc68k */
 +	rem += (offset - corr);
 +	while (rem < 0) {
 +		rem += SECSPERDAY;
 +		--days;
 +	}
 +	while (rem >= SECSPERDAY) {
 +		rem -= SECSPERDAY;
 +		++days;
 +	}
 +	tmp->tm_hour = (int) (rem / SECSPERHOUR);
 +	rem = rem % SECSPERHOUR;
 +	tmp->tm_min = (int) (rem / SECSPERMIN);
 +	tmp->tm_sec = (int) (rem % SECSPERMIN);
 +	if (hit)
 +		/*
 +		** A positive leap second requires a special
 +		** representation.  This uses "... ??:59:60" et seq.
 +		*/
 +		tmp->tm_sec += hit;
 +	tmp->tm_wday = (int) ((EPOCH_WDAY + days) % DAYSPERWEEK);
 +	if (tmp->tm_wday < 0)
 +		tmp->tm_wday += DAYSPERWEEK;
 +	y = EPOCH_YEAR;
 +	if (days >= 0)
 +		for ( ; ; ) {
 +			yleap = isleap(y);
 +			if (days < (long) year_lengths[yleap])
 +				break;
 +			++y;
 +			days = days - (long) year_lengths[yleap];
 +		}
 +	else do {
 +		--y;
 +		yleap = isleap(y);
 +		days = days + (long) year_lengths[yleap];
 +	} while (days < 0);
 +	tmp->tm_year = y - TM_YEAR_BASE;
 +	tmp->tm_yday = (int) days;
 +	ip = mon_lengths[yleap];
 +	for (tmp->tm_mon = 0; days >= (long) ip[tmp->tm_mon]; ++(tmp->tm_mon))
 +		days = days - (long) ip[tmp->tm_mon];
 +	tmp->tm_mday = (int) (days + 1);
 +	tmp->tm_isdst = 0;
 +#ifdef TM_GMTOFF
 +	tmp->TM_GMTOFF = offset;
 +#endif /* defined TM_GMTOFF */
 +}
 +
 +/*
 +** Adapted from code provided by Robert Elz, who writes:
 +**	The "best" way to do mktime I think is based on an idea of Bob
 +**	Kridle's (so its said...) from a long time ago. (mtxinu!kridle now).
 +**	It does a binary search of the time_t space.  Since time_t's are
 +**	just 32 bits, its a max of 32 iterations (even at 64 bits it
 +**	would still be very reasonable).
 +*/
 +
 +#ifndef WRONG
 +#define WRONG	(-1)
 +#endif /* !defined WRONG */
 +
 +/*
 +** Simplified normalize logic courtesy Paul Eggert (eggert@twinsun.com).
 +*/
 +
 +static int
 +increment_overflow(number, delta)
 +int *	number;
 +int	delta;
 +{
 +	int	number0;
 +
 +	number0 = *number;
 +	*number += delta;
 +	return (*number < number0) != (delta < 0);
 +}
 +
 +static int
 +normalize_overflow(tensptr, unitsptr, base)
 +int * const	tensptr;
 +int * const	unitsptr;
 +const int	base;
 +{
 +	register int	tensdelta;
 +
 +	tensdelta = (*unitsptr >= 0) ?
 +		(*unitsptr / base) :
 +		(-1 - (-1 - *unitsptr) / base);
 +	*unitsptr -= tensdelta * base;
 +	return increment_overflow(tensptr, tensdelta);
 +}
 +
 +static int
 +tmcomp(atmp, btmp)
 +register const struct tm * const atmp;
 +register const struct tm * const btmp;
 +{
 +	register int	result;
 +
 +	if ((result = (atmp->tm_year - btmp->tm_year)) == 0 &&
 +		(result = (atmp->tm_mon - btmp->tm_mon)) == 0 &&
 +		(result = (atmp->tm_mday - btmp->tm_mday)) == 0 &&
 +		(result = (atmp->tm_hour - btmp->tm_hour)) == 0 &&
 +		(result = (atmp->tm_min - btmp->tm_min)) == 0)
 +			result = atmp->tm_sec - btmp->tm_sec;
 +	return result;
 +}
 +
 +static time_t
 +time2(tmp, funcp, offset, okayp)
 +struct tm * const	tmp;
 +void (* const		funcp) P((const time_t*, long, struct tm*));
 +const long		offset;
 +int * const		okayp;
 +{
 +	register const struct state *	sp;
 +	register int			dir;
 +	register int			bits;
 +	register int			i, j ;
 +	register int			saved_seconds;
 +	time_t				newt;
 +	time_t				t;
 +	struct tm			yourtm, mytm;
 +
 +	*okayp = FALSE;
 +	yourtm = *tmp;
 +	if (normalize_overflow(&yourtm.tm_hour, &yourtm.tm_min, MINSPERHOUR))
 +		return WRONG;
 +	if (normalize_overflow(&yourtm.tm_mday, &yourtm.tm_hour, HOURSPERDAY))
 +		return WRONG;
 +	if (normalize_overflow(&yourtm.tm_year, &yourtm.tm_mon, MONSPERYEAR))
 +		return WRONG;
 +	/*
 +	** Turn yourtm.tm_year into an actual year number for now.
 +	** It is converted back to an offset from TM_YEAR_BASE later.
 +	*/
 +	if (increment_overflow(&yourtm.tm_year, TM_YEAR_BASE))
 +		return WRONG;
 +	while (yourtm.tm_mday <= 0) {
 +		if (increment_overflow(&yourtm.tm_year, -1))
 +			return WRONG;
 +		yourtm.tm_mday += year_lengths[isleap(yourtm.tm_year)];
 +	}
 +	while (yourtm.tm_mday > DAYSPERLYEAR) {
 +		yourtm.tm_mday -= year_lengths[isleap(yourtm.tm_year)];
 +		if (increment_overflow(&yourtm.tm_year, 1))
 +			return WRONG;
 +	}
 +	for ( ; ; ) {
 +		i = mon_lengths[isleap(yourtm.tm_year)][yourtm.tm_mon];
 +		if (yourtm.tm_mday <= i)
 +			break;
 +		yourtm.tm_mday -= i;
 +		if (++yourtm.tm_mon >= MONSPERYEAR) {
 +			yourtm.tm_mon = 0;
 +			if (increment_overflow(&yourtm.tm_year, 1))
 +				return WRONG;
 +		}
 +	}
 +	if (increment_overflow(&yourtm.tm_year, -TM_YEAR_BASE))
 +		return WRONG;
 +	if (yourtm.tm_year + TM_YEAR_BASE < EPOCH_YEAR) {
 +		/*
 +		** We can't set tm_sec to 0, because that might push the
 +		** time below the minimum representable time.
 +		** Set tm_sec to 59 instead.
 +		** This assumes that the minimum representable time is
 +		** not in the same minute that a leap second was deleted from,
 +		** which is a safer assumption than using 58 would be.
 +		*/
 +		if (increment_overflow(&yourtm.tm_sec, 1 - SECSPERMIN))
 +			return WRONG;
 +		saved_seconds = yourtm.tm_sec;
 +		yourtm.tm_sec = SECSPERMIN - 1;
 +	} else {
 +		saved_seconds = yourtm.tm_sec;
 +		yourtm.tm_sec = 0;
 +	}
 +	/*
 +	** Calculate the number of magnitude bits in a time_t
 +	** (this works regardless of whether time_t is
 +	** signed or unsigned, though lint complains if unsigned).
 +	*/
 +	for (bits = 0, t = 1; t > 0; ++bits, t <<= 1)
 +		continue;
 +	/*
 +	** If time_t is signed, then 0 is the median value,
 +	** if time_t is unsigned, then 1 << bits is median.
 +	*/
 +	t = (t < 0) ? 0 : ((time_t) 1 << bits);
 +	for ( ; ; ) {
 +		(*funcp)(&t, offset, &mytm);
 +		dir = tmcomp(&mytm, &yourtm);
 +		if (dir != 0) {
 +			if (bits-- < 0)
 +				return WRONG;
 +			if (bits < 0)
 +				--t;
 +			else if (dir > 0)
 +				t -= (time_t) 1 << bits;
 +			else	t += (time_t) 1 << bits;
 +			continue;
 +		}
 +		if (yourtm.tm_isdst < 0 || mytm.tm_isdst == yourtm.tm_isdst)
 +			break;
 +		/*
 +		** Right time, wrong type.
 +		** Hunt for right time, right type.
 +		** It's okay to guess wrong since the guess
 +		** gets checked.
 +		*/
 +		/*
 +		** The (void *) casts are the benefit of SunOS 3.3 on Sun 2's.
 +		*/
 +		sp = (const struct state *)
 +			(((void *) funcp == (void *) localsub) ?
 +			lclptr : gmtptr);
 +#ifdef ALL_STATE
 +		if (sp == NULL)
 +			return WRONG;
 +#endif /* defined ALL_STATE */
 +		for (i = 0; i < sp->typecnt; ++i) {
 +			if (sp->ttis[i].tt_isdst != yourtm.tm_isdst)
 +				continue;
 +			for (j = 0; j < sp->typecnt; ++j) {
 +				if (sp->ttis[j].tt_isdst == yourtm.tm_isdst)
 +					continue;
 +				newt = t + sp->ttis[j].tt_gmtoff -
 +					sp->ttis[i].tt_gmtoff;
 +				(*funcp)(&newt, offset, &mytm);
 +				if (tmcomp(&mytm, &yourtm) != 0)
 +					continue;
 +				if (mytm.tm_isdst != yourtm.tm_isdst)
 +					continue;
 +				/*
 +				** We have a match.
 +				*/
 +				t = newt;
 +				goto label;
 +			}
 +		}
 +		return WRONG;
 +	}
 +label:
 +	newt = t + saved_seconds;
 +	if ((newt < t) != (saved_seconds < 0))
 +		return WRONG;
 +	t = newt;
 +	(*funcp)(&t, offset, tmp);
 +	*okayp = TRUE;
 +	return t;
 +}
 +
 +static time_t
 +time1(tmp, funcp, offset)
 +struct tm * const	tmp;
 +void (* const		funcp) P((const time_t*, long, struct tm*));
 +const long		offset;
 +{
 +	register time_t			t;
 +	register const struct state *	sp;
 +	register int			samei, otheri;
 +	int				okay;
 +
 +	if (tmp->tm_isdst > 1)
 +		tmp->tm_isdst = 1;
 +	t = time2(tmp, funcp, offset, &okay);
 +#ifdef PCTS
 +	/*
 +	** PCTS code courtesy Grant Sullivan (grant@osf.org).
 +	*/
 +	if (okay)
 +		return t;
 +	if (tmp->tm_isdst < 0)
 +		tmp->tm_isdst = 0;	/* reset to std and try again */
 +#endif /* defined PCTS */
 +#ifndef PCTS
 +	if (okay || tmp->tm_isdst < 0)
 +		return t;
 +#endif /* !defined PCTS */
 +	/*
 +	** We're supposed to assume that somebody took a time of one type
 +	** and did some math on it that yielded a "struct tm" that's bad.
 +	** We try to divine the type they started from and adjust to the
 +	** type they need.
 +	*/
 +	/*
 +	** The (void *) casts are the benefit of SunOS 3.3 on Sun 2's.
 +	*/
 +	sp = (const struct state *) (((void *) funcp == (void *) localsub) ?
 +		lclptr : gmtptr);
 +#ifdef ALL_STATE
 +	if (sp == NULL)
 +		return WRONG;
 +#endif /* defined ALL_STATE */
 +	for (samei = 0; samei < sp->typecnt; ++samei) {
 +		if (sp->ttis[samei].tt_isdst != tmp->tm_isdst)
 +			continue;
 +		for (otheri = 0; otheri < sp->typecnt; ++otheri) {
 +			if (sp->ttis[otheri].tt_isdst == tmp->tm_isdst)
 +				continue;
 +			tmp->tm_sec += sp->ttis[otheri].tt_gmtoff -
 +					sp->ttis[samei].tt_gmtoff;
 +			tmp->tm_isdst = !tmp->tm_isdst;
 +			t = time2(tmp, funcp, offset, &okay);
 +			if (okay)
 +				return t;
 +			tmp->tm_sec -= sp->ttis[otheri].tt_gmtoff -
 +					sp->ttis[samei].tt_gmtoff;
 +			tmp->tm_isdst = !tmp->tm_isdst;
 +		}
 +	}
 +	return WRONG;
 +}
 +
 +time_t
 +mktime(tmp)
 +struct tm * const	tmp;
 +{
 +	tzset();
 +	return time1(tmp, localsub, 0L);
 +}
 +
 +#ifdef STD_INSPIRED
 +
 +time_t
 +timelocal(tmp)
 +struct tm * const	tmp;
 +{
 +	tmp->tm_isdst = -1;	/* in case it wasn't initialized */
 +	return mktime(tmp);
 +}
 +
 +time_t
 +timegm(tmp)
 +struct tm * const	tmp;
 +{
 +	tmp->tm_isdst = 0;
 +	return time1(tmp, gmtsub, 0L);
 +}
 +
 +time_t
 +timeoff(tmp, offset)
 +struct tm * const	tmp;
 +const long		offset;
 +{
 +	tmp->tm_isdst = 0;
 +	return time1(tmp, gmtsub, offset);
 +}
 +
 +#endif /* defined STD_INSPIRED */
  #endif
  
  /* we want to downcase the type/subtype for comparison purposes
 --- src/modules/proxy/proxy_cache.c.dist	Sun Jun 14 04:00:19 1998
 +++ src/modules/proxy/proxy_cache.c	Tue Jul  7 16:36:36 1998
 @@ -64,7 +64,11 @@
  #ifdef WIN32
  #include <sys/utime.h>
  #else
 +#ifdef NEWSOS42
 +#include <sys/types.h>
 +#else
  #include <utime.h>
 +#endif /* NEWSOS42 */
  #endif /* WIN32 */
  #include "multithread.h"
  #include "ap_md5.h"
 @@ -230,7 +234,7 @@
  			fprintf(stderr, "httpd: setsid failed\n");
  			exit(1);
  		    }
 -#elif defined(NEXT) || defined(NEWSOS)
 +#elif defined(NEXT)
  		    if (setpgrp(0, getpid()) == -1 || (pgrp = getpgrp(0)) == -1) {
  			perror("setpgrp");
  			fprintf(stderr, "httpd: setpgrp or getpgrp failed\n");
 --- src/modules/standard/mod_mime_magic.c.dist	Mon Jun 15 10:00:17 1998
 +++ src/modules/standard/mod_mime_magic.c	Tue Jul  7 16:36:39 1998
 @@ -130,7 +130,11 @@
  #include "http_log.h"
  #include "http_protocol.h"
  
 +#if defined(NEWSOS42)
 +#include <sys/types.h>
 +#else
  #include <utime.h>
 +#endif
  
  
  /*
 --- src/modules/standard/mod_status.c.dist	Tue Jun 16 04:00:18 1998
 +++ src/modules/standard/mod_status.c	Tue Jul  7 16:36:52 1998
 @@ -130,6 +130,10 @@
  #endif
  #endif /* NEXT */
  
 +#if defined(NEWSOS42)
 +#include <machine/machparam.h>
 +#endif
 +
  #define STATUS_MAXLINE		64
  
  #define KBYTE			1024
 @@ -232,6 +236,8 @@
      long req_time;
  #if defined(NEXT)
      float tick = HZ;
 +#elif defined(NEWSOS42)
 +    float tick = CLK_TCK;
  #elif !defined(NO_TIMES)
      float tick = sysconf(_SC_CLK_TCK);
  #endif

From: Makoto MATSUSHITA (=?ISO-2022-JP?B?GyRCJF4kRCQ3JD8kXiQzJEgbKEI=?=) <matusita@ics.es.osaka-u.ac.jp>
To: apbugs@apache.org
Cc: nakaji@zeisei.dpri.kyoto-u.ac.jp
Subject: Re: general/2516: Compilation fails: wait() wants "union wait status" and some "redefinition" warnings
Date: Sun, 26 Jul 1998 10:19:14 +0900

 dgaudet> In any event we've already had to fix a few things like this
 dgaudet> in 1.3.1-dev. If one of you could pick up a snapshot at
 dgaudet> ftp://dev.apache.org/httpd/from-cvs/ and resubmit a patch
 dgaudet> that would be great.
 
 I've already send a mail about that, however, no response about
 that. What it is going now ? ignored, analyzing, or rejected? I want to
 decide I should make a patch for Apache 1.3.1, 1.3.2, ... forever or not.
 
 -- -
 Makoto `MAR' MATSUSHITA
State-Changed-From-To: open-feedback
State-Changed-By: lars
State-Changed-When: Sat Feb 20 17:23:16 PST 1999
State-Changed-Why:
[This is a standard response.]
This Apache problem report has not been updated recently.
Please reply to this message if you have any additional
information about this issue, or if you have answers to
any questions that have been posed to you.  If there are
no outstanding questions, please consider this a request
to try to reproduce the problem with the latest software
release, if one has been made since last contact.  If we
don't hear from you, this report will be closed.
If you have information to add, BE SURE to reply to this
message and include the apbugs@Apache.Org address so it
will be attached to the problem report!
State-Changed-From-To: feedback-closed
State-Changed-By: lars
State-Changed-When: Sun Jun 13 04:49:12 PDT 1999
State-Changed-Why:
[This is a standard response.]
No response from submitter, assuming issue has been resolved.
>Unformatted:
[In order for any reply to be added to the PR database, ]
[you need to include <apbugs@Apache.Org> in the Cc line ]
[and leave the subject line UNCHANGED.  This is not done]
[automatically because of the potential for mail loops. ]



